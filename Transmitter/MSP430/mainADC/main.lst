
main.elf:     file format elf32-msp430

SYMBOL TABLE:
0000f800 l    d  .text	00000000 .text
00000200 l    d  .bss	00000000 .bss
0000ffe0 l    d  .vectors	00000000 .vectors
00000000 l    d  .debug_aranges	00000000 .debug_aranges
00000000 l    d  .debug_pubnames	00000000 .debug_pubnames
00000000 l    d  .debug_info	00000000 .debug_info
00000000 l    d  .debug_abbrev	00000000 .debug_abbrev
00000000 l    d  .debug_line	00000000 .debug_line
00000000 l    d  .debug_frame	00000000 .debug_frame
00000000 l    d  .debug_str	00000000 .debug_str
00000000 l    d  .debug_loc	00000000 .debug_loc
00000000 l    d  .debug_pubtypes	00000000 .debug_pubtypes
00000000 l    d  .debug_ranges	00000000 .debug_ranges
00000000 l    df *ABS*	00000000 main.c
0000fb1c l     O .text	00000010 asciiCode
0000f8f2 l       .text	00000000 __br_unexpected_
0000007c g       *ABS*	00000000 __USISR
00000057 g       *ABS*	00000000 __BCSCTL1
00000174 g       *ABS*	00000000 __TACCR1
00000000 g       *ABS*	00000000 __data_size
0000f8f2  w      .text	00000000 __isr_14
0000fac6 g     F .text	00000008 ADC10_ISR
0000007a g       *ABS*	00000000 __USICKCTL
00000128 g       *ABS*	00000000 __FCTL1
00000024 g       *ABS*	00000000 __P1IES
0000f8f2  w      .text	00000000 __isr_4
00000002 g       *ABS*	00000000 __IFG1
0000f944 g     F .text	000000f8 TransmitADCValue
0000012e g       *ABS*	00000000 __TAIV
00000000 g       .vectors	00000000 _efartext
0000002b g       *ABS*	00000000 __P2IFG
0000fa3c g     F .text	00000018 setVlo
0000fb2e g       *ABS*	00000000 _etext
0000face g     F .text	0000004e Timer_A
00000032 g       *ABS*	00000000 __bss_size
00000078 g       *ABS*	00000000 __USICTL
0000f8ec  w      .text	00000000 __stop_progExec__
0000002d g       *ABS*	00000000 __P2IE
0000f8f2  w      .text	00000000 __isr_11
00000025 g       *ABS*	00000000 __P1IE
00000049 g       *ABS*	00000000 __ADC10DTC1
0000fac6 g       .text	00000000 __isr_5
0000fb2e g       *ABS*	00000000 __data_load_start
0000f8f2 g       .text	00000000 __dtors_end
00000053 g       *ABS*	00000000 __BCSCTL3
000001bc g       *ABS*	00000000 __ADC10SA
0000007a g       *ABS*	00000000 __USICCTL
0000f8f2  w      .text	00000000 __isr_2
0000f904 g     F .text	00000040 Transmit
00000160 g       *ABS*	00000000 __TACTL
0000012c g       *ABS*	00000000 __FCTL3
0000fab2 g       .text	00000000 __isr_10
0000002e g       *ABS*	00000000 __P2SEL
00000202 g     O .bss	00000004 tempCalibrated
00000023 g       *ABS*	00000000 __P1IFG
0000004a g       *ABS*	00000000 __ADC10AE0
00000172 g       *ABS*	00000000 __TACCR0
00000056 g       *ABS*	00000000 __DCOCTL
0000f8f2  w      .text	00000000 __isr_7
0000ffe0 g     O .vectors	00000020 __ivtbl_16
00000028 g       *ABS*	00000000 __P2IN
00000206 g     O .bss	00000004 tempAverage
0000fa66 g     F .text	0000004c ConfigureAdcTempSensor
000001b4 g       *ABS*	00000000 __ADC10MEM
0000f8f2  w      .text	00000000 __isr_0
00000029 g       *ABS*	00000000 __P2OUT
0000012a g       *ABS*	00000000 __FCTL2
0000f824  w      .text	00000000 __do_clear_bss
00000021 g       *ABS*	00000000 __P1OUT
0000002c g       *ABS*	00000000 __P2IES
00000026 g       *ABS*	00000000 __P1SEL
0000020a g     O .bss	00000001 ADCDone
0000020c g     O .bss	00000020 tempMeasured
00000079 g       *ABS*	00000000 __USICTL1
00000200 g     O .bss	00000001 tempMeasuredPosition
00000027 g       *ABS*	00000000 __P1REN
0000fb2c  w      .text	00000000 _unexpected_
0000f8f2  w      .text	00000000 __isr_8
0000f8f2  w      .text	00000000 __isr_3
0000f800  w      .text	00000000 _reset_vector__
0000fab2 g     F .text	00000014 watchdog_timer
0000f8f2 g       .text	00000000 __ctors_start
0000f8f2  w      .text	00000000 __isr_12
0000f80e  w      .text	00000000 __do_copy_data
00000200 g       .bss	00000000 __bss_start
0000022c g     O .bss	00000001 BitCnt
0000f838 g     F .text	000000b4 main
0000fa54 g     F .text	00000012 delay_ms
0000022e g     O .bss	00000002 TXByte
0000f8f2  w      .text	00000000 __isr_13
00000170 g       *ABS*	00000000 __TAR
00000162 g       *ABS*	00000000 __TACCTL0
00010000 g       .vectors	00000000 _vectors_end
0000002a g       *ABS*	00000000 __P2DIR
0000002f g       *ABS*	00000000 __P2REN
0000007d g       *ABS*	00000000 __USISRH
00000230 g     O .bss	00000002 ADCValue
000001b0 g       *ABS*	00000000 __ADC10CTL0
0000face g       .text	00000000 __isr_9
000010fe g       *ABS*	00000000 __CALDCO_1MHZ
0000f800  w      .text	00000000 __init_stack
0000f8f2 g       .text	00000000 __dtors_start
0000f8f2  w      .text	00000000 __isr_6
0000f8f2 g       .text	00000000 __ctors_end
00000280 g       *ABS*	00000000 __stack
0000f8f2  w      .text	00000000 __isr_1
00000200 g       .text	00000000 _edata
00000232 g       .bss	00000000 _end
0000007b g       *ABS*	00000000 __USICNT
00000048 g       *ABS*	00000000 __ADC10DTC0
000001b2 g       *ABS*	00000000 __ADC10CTL1
00000058 g       *ABS*	00000000 __BCSCTL2
0000f8ec  w      .text	00000000 _endless_loop__
00000022 g       *ABS*	00000000 __P1DIR
00000164 g       *ABS*	00000000 __TACCTL1
000010ff g       *ABS*	00000000 __CALBC1_1MHZ
0000f804  w      .text	00000000 __low_level_init
0000f8f6 g     F .text	0000000e setClockTrans
00000200 g       .text	00000000 __data_start
00000120 g       *ABS*	00000000 __WDTCTL
00000000 g       *ABS*	00000000 __IE1
00000078 g       *ABS*	00000000 __USICTL0
00000020 g       *ABS*	00000000 __P1IN
0000007c g       *ABS*	00000000 __USISRL



Disassembly of section .text:

0000f800 <__init_stack>:
    f800:	31 40 80 02 	mov	#640,	r1	;#0x0280

0000f804 <__low_level_init>:
    f804:	15 42 20 01 	mov	&0x0120,r5	
    f808:	75 f3       	and.b	#-1,	r5	;r3 As==11
    f80a:	35 d0 08 5a 	bis	#23048,	r5	;#0x5a08

0000f80e <__do_copy_data>:
    f80e:	3f 40 00 00 	mov	#0,	r15	;#0x0000
    f812:	0f 93       	tst	r15		
    f814:	07 24       	jz	$+16     	;abs 0xf824
    f816:	82 45 20 01 	mov	r5,	&0x0120	
    f81a:	2f 83       	decd	r15		
    f81c:	9f 4f 2e fb 	mov	-1234(r15),512(r15);0xfb2e(r15), 0x0200(r15)
    f820:	00 02 
    f822:	f9 23       	jnz	$-12     	;abs 0xf816

0000f824 <__do_clear_bss>:
    f824:	3f 40 32 00 	mov	#50,	r15	;#0x0032
    f828:	0f 93       	tst	r15		
    f82a:	06 24       	jz	$+14     	;abs 0xf838
    f82c:	82 45 20 01 	mov	r5,	&0x0120	
    f830:	1f 83       	dec	r15		
    f832:	cf 43 00 02 	mov.b	#0,	512(r15);r3 As==00, 0x0200(r15)
    f836:	fa 23       	jnz	$-10     	;abs 0xf82c

0000f838 <main>:

int main (){

  unsigned char i;

  WDTCTL = WDTPW + WDTHOLD;              // Stop WDT
    f838:	b2 40 80 5a 	mov	#23168,	&0x0120	;#0x5a80
    f83c:	20 01 
  }
}
 
void setClockTrans()
{
  BCSCTL1 = CALBC1_1MHZ;           // Set range
    f83e:	d2 42 ff 10 	mov.b	&0x10ff,&0x0057	
    f842:	57 00 
  DCOCTL = CALDCO_1MHZ;            // SMCLK = DCO = 1MHz
    f844:	d2 42 fe 10 	mov.b	&0x10fe,&0x0056	
    f848:	56 00 

  unsigned char i;

  WDTCTL = WDTPW + WDTHOLD;              // Stop WDT
  setClockTrans();
  __bis_SR_register(GIE);                // interrupts enabled 
    f84a:	32 d2       	eint			

  P1SEL |= TXD + APC220_CTL;             //
    f84c:	f2 d0 03 00 	bis.b	#3,	&0x0026	;#0x0003
    f850:	26 00 
  P1DIR |= TXD + APC220_CTL;             //
    f852:	f2 d0 03 00 	bis.b	#3,	&0x0022	;#0x0003
    f856:	22 00 
  P1REN |=  APC220_CTL;             //
    f858:	d2 d3 27 00 	bis.b	#1,	&0x0027	;r3 As==01

  //P1OUT &= ~ BIT0;
  P1OUT = 0x00;
    f85c:	c2 43 21 00 	mov.b	#0,	&0x0021	;r3 As==00

  ConfigureAdcTempSensor();
    f860:	b0 12 66 fa 	call	#0xfa66	

  __enable_interrupt();                     // Enable interrupts.
    f864:	32 d2       	eint			

  while(1)
  {  
    ADC10CTL0 |= ENC + ADC10SC;             // Sampling and conversion start
    f866:	b2 d0 03 00 	bis	#3,	&0x01b0	;#0x0003
    f86a:	b0 01 
    __bis_SR_register(CPUOFF + GIE);        // LPM0 with interrupts enabled
    f86c:	32 d0 18 00 	bis	#24,	r2	;#0x0018

    /* Moving average filter out of 8 values to somewhat stabilize sampled ADC */
    tempMeasured[tempMeasuredPosition++] = ADC10MEM;
    f870:	5e 42 00 02 	mov.b	&0x0200,r14	
    f874:	4f 4e       	mov.b	r14,	r15	
    f876:	0f 5f       	rla	r15		
    f878:	0f 5f       	rla	r15		
    f87a:	3f 50 0c 02 	add	#524,	r15	;#0x020c
    f87e:	9f 42 b4 01 	mov	&0x01b4,0(r15)	;0x0000(r15)
    f882:	00 00 
    f884:	8f 43 02 00 	mov	#0,	2(r15)	;r3 As==00, 0x0002(r15)
    f888:	4f 4e       	mov.b	r14,	r15	
    f88a:	5f 53       	inc.b	r15		
    f88c:	c2 4f 00 02 	mov.b	r15,	&0x0200	
    if (tempMeasuredPosition == 8)
    f890:	7f 92       	cmp.b	#8,	r15	;r2 As==11
    f892:	29 24       	jz	$+84     	;abs 0xf8e6
      tempMeasuredPosition = 0;
    tempAverage = 0;
    f894:	3d 40 0c 02 	mov	#524,	r13	;#0x020c
void setVlo ();
void ConfigureAdcTempSensor(void);

#include "transmitADCValue.c"

int main (){
    f898:	0e 43       	clr	r14		
    f89a:	0f 43       	clr	r15		
    tempMeasured[tempMeasuredPosition++] = ADC10MEM;
    if (tempMeasuredPosition == 8)
      tempMeasuredPosition = 0;
    tempAverage = 0;
    for (i = 0; i < 8; i++)
      tempAverage += tempMeasured[i];
    f89c:	3e 5d       	add	@r13+,	r14	
    f89e:	3f 6d       	addc	@r13+,	r15	
    /* Moving average filter out of 8 values to somewhat stabilize sampled ADC */
    tempMeasured[tempMeasuredPosition++] = ADC10MEM;
    if (tempMeasuredPosition == 8)
      tempMeasuredPosition = 0;
    tempAverage = 0;
    for (i = 0; i < 8; i++)
    f8a0:	3d 90 2c 02 	cmp	#556,	r13	;#0x022c
    f8a4:	fb 23       	jnz	$-8      	;abs 0xf89c
      tempAverage += tempMeasured[i];
    tempAverage >>= 3;
    f8a6:	0f 11       	rra	r15		
    f8a8:	0e 10       	rrc	r14		
    f8aa:	0f 11       	rra	r15		
    f8ac:	0e 10       	rrc	r14		
    f8ae:	0f 11       	rra	r15		
    f8b0:	0e 10       	rrc	r14		
    f8b2:	82 4e 06 02 	mov	r14,	&0x0206	
    f8b6:	82 4f 08 02 	mov	r15,	&0x0208	

    ADCValue = tempAverage;
    f8ba:	82 4e 30 02 	mov	r14,	&0x0230	
    // Habilitacion del APC220 para transmitir
    //P1OUT |=  BIT0;
    P1OUT =  0x01;
    f8be:	d2 43 21 00 	mov.b	#1,	&0x0021	;r3 As==01
    //  Se necesita un tiempo de 50 ms para iniciar transmision luego de poner en 1 EN y SET 
    //  en APC220
    for (i = 0; i < 100; i++)
    f8c2:	4f 43       	clr.b	r15		
      __delay_cycles(500);
    f8c4:	3e 40 a6 00 	mov	#166,	r14	;#0x00a6
    f8c8:	1e 83       	dec	r14		
    f8ca:	fe 23       	jnz	$-2      	;abs 0xf8c8
    // Habilitacion del APC220 para transmitir
    //P1OUT |=  BIT0;
    P1OUT =  0x01;
    //  Se necesita un tiempo de 50 ms para iniciar transmision luego de poner en 1 EN y SET 
    //  en APC220
    for (i = 0; i < 100; i++)
    f8cc:	5f 53       	inc.b	r15		
    f8ce:	7f 90 64 00 	cmp.b	#100,	r15	;#0x0064
    f8d2:	f8 23       	jnz	$-14     	;abs 0xf8c4
      __delay_cycles(500);

    TransmitADCValue ();    
    f8d4:	b0 12 44 f9 	call	#0xf944	
 
    // Des-Habilitacion del APC220 para transmitir
    //P1OUT &= ~ BIT0;
    P1OUT = 0x00;
    f8d8:	c2 43 21 00 	mov.b	#0,	&0x0021	;r3 As==00
     
    //TXByte = 65;
    //Transmit(); 
    setVlo ();
    f8dc:	b0 12 3c fa 	call	#0xfa3c	
    _BIS_SR(LPM3_bits + GIE);               // Enter LPM3
    f8e0:	32 d0 d8 00 	bis	#216,	r2	;#0x00d8
    f8e4:	c0 3f       	jmp	$-126    	;abs 0xf866
    __bis_SR_register(CPUOFF + GIE);        // LPM0 with interrupts enabled

    /* Moving average filter out of 8 values to somewhat stabilize sampled ADC */
    tempMeasured[tempMeasuredPosition++] = ADC10MEM;
    if (tempMeasuredPosition == 8)
      tempMeasuredPosition = 0;
    f8e6:	c2 43 00 02 	mov.b	#0,	&0x0200	;r3 As==00
    f8ea:	d4 3f       	jmp	$-86     	;abs 0xf894

0000f8ec <__stop_progExec__>:
    f8ec:	32 d0 f0 00 	bis	#240,	r2	;#0x00f0
    f8f0:	fd 3f       	jmp	$-4      	;abs 0xf8ec

0000f8f2 <__ctors_end>:
    f8f2:	30 40 2c fb 	br	#0xfb2c	

0000f8f6 <setClockTrans>:
  }
}
 
void setClockTrans()
{
  BCSCTL1 = CALBC1_1MHZ;           // Set range
    f8f6:	d2 42 ff 10 	mov.b	&0x10ff,&0x0057	
    f8fa:	57 00 
  DCOCTL = CALDCO_1MHZ;            // SMCLK = DCO = 1MHz
    f8fc:	d2 42 fe 10 	mov.b	&0x10fe,&0x0056	
    f900:	56 00 
}
    f902:	30 41       	ret			

0000f904 <Transmit>:

// Function Transmits Character from TXByte 
void Transmit()
{ 
  CCTL0 = OUT;                               // TXD Idle as Mark
    f904:	a2 42 62 01 	mov	#4,	&0x0162	;r2 As==10
  TACTL = TASSEL_2 + MC_2;               // SMCLK, continuous mode
    f908:	b2 40 20 02 	mov	#544,	&0x0160	;#0x0220
    f90c:	60 01 
 
  BitCnt = 0xA;                       // Load Bit counter, 8 bits + ST/SP
    f90e:	f2 40 0a 00 	mov.b	#10,	&0x022c	;#0x000a
    f912:	2c 02 
  CCR0 = TAR;
    f914:	92 42 70 01 	mov	&0x0170,&0x0172	
    f918:	72 01 
   
  CCR0 += Bitime;                  // Set time till first bit
    f91a:	b2 50 68 00 	add	#104,	&0x0172	;#0x0068
    f91e:	72 01 
  TXByte |= 0x100;                 // Add stop bit to TXByte (which is logical 1)
  TXByte = TXByte << 1;            // Add start bit (which is logical 0)
    f920:	1f 42 2e 02 	mov	&0x022e,r15	
    f924:	3f d0 00 01 	bis	#256,	r15	;#0x0100
    f928:	0f 5f       	rla	r15		
    f92a:	82 4f 2e 02 	mov	r15,	&0x022e	
   
  CCTL0 =  CCIS0 + OUTMOD0 + CCIE; // Set signal, intial value, enable interrupts
    f92e:	b2 40 30 10 	mov	#4144,	&0x0162	;#0x1030
    f932:	62 01 
  while ( CCTL0 & CCIE );          // Wait for TX completion
    f934:	b2 b0 10 00 	bit	#16,	&0x0162	;#0x0010
    f938:	62 01 
    f93a:	fc 23       	jnz	$-6      	;abs 0xf934
  TACTL = TASSEL_2;             // SMCLK, timer off (for power consumption)
    f93c:	b2 40 00 02 	mov	#512,	&0x0160	;#0x0200
    f940:	60 01 
}
    f942:	30 41       	ret			

0000f944 <TransmitADCValue>:

#define SensorId     12
#define codFunc       3


void TransmitADCValue (){
    f944:	0b 12       	push	r11		
    f946:	0a 12       	push	r10		
    f948:	09 12       	push	r9		
  unsigned int cksum = 0;

  /*************************************************************/  
  // Transmitir Comienzo  de Mensaje ':'
  /*************************************************************/  
   TXByte = ':';
    f94a:	b2 40 3a 00 	mov	#58,	&0x022e	;#0x003a
    f94e:	2e 02 
   cksum = cksum + TXByte;
   Transmit();
    f950:	b0 12 04 f9 	call	#0xf904	
  /*************************************************************/  
  //  Transmitir el SensorId
  /*************************************************************/  

   TXByte = (SensorId >> 4) & 0x000F;
   TXByte  = asciiCode[TXByte];
    f954:	b2 40 30 00 	mov	#48,	&0x022e	;#0x0030
    f958:	2e 02 
   cksum = cksum + TXByte;
   Transmit();                                           // Send
    f95a:	b0 12 04 f9 	call	#0xf904	


  TXByte = SensorId & 0x000F;
  TXByte  = asciiCode[TXByte];
    f95e:	b2 40 43 00 	mov	#67,	&0x022e	;#0x0043
    f962:	2e 02 
  cksum = cksum + TXByte;
  Transmit();                                           // Send
    f964:	b0 12 04 f9 	call	#0xf904	

  /*************************************************************/  
  // Transmitir el codFunc 
  /*************************************************************/  
  TXByte = (codFunc >> 4) & 0x000F;
  TXByte  = asciiCode[TXByte];
    f968:	b2 40 30 00 	mov	#48,	&0x022e	;#0x0030
    f96c:	2e 02 
  cksum = cksum + TXByte;
  Transmit();                                           // Send
    f96e:	b0 12 04 f9 	call	#0xf904	


  TXByte = codFunc & 0x000F;
  TXByte  = asciiCode[TXByte];
    f972:	b2 40 33 00 	mov	#51,	&0x022e	;#0x0033
    f976:	2e 02 
  cksum = cksum + TXByte;
  Transmit();                                           // Send
    f978:	b0 12 04 f9 	call	#0xf904	


  /*************************************************************/  
  // Transmitir el valor del ADC
  /*************************************************************/
  TXByte = (ADCValue>>12) & 0x000F;
    f97c:	1f 42 30 02 	mov	&0x0230,r15	
    f980:	8f 10       	swpb	r15		
    f982:	3f f0 ff 00 	and	#255,	r15	;#0x00ff
    f986:	12 c3       	clrc			
    f988:	0f 10       	rrc	r15		
    f98a:	0f 11       	rra	r15		
    f98c:	0f 11       	rra	r15		
    f98e:	0f 11       	rra	r15		
  TXByte  = asciiCode[TXByte];
    f990:	5b 4f 1c fb 	mov.b	-1252(r15),r11	;0xfb1c(r15)
    f994:	8b 11       	sxt	r11		
    f996:	82 4b 2e 02 	mov	r11,	&0x022e	
  cksum = cksum + TXByte;
  Transmit();                                           // Send
    f99a:	b0 12 04 f9 	call	#0xf904	

  TXByte = (ADCValue>>8) & 0x000F;
    f99e:	1f 42 30 02 	mov	&0x0230,r15	
    f9a2:	8f 10       	swpb	r15		
    f9a4:	3f f0 0f 00 	and	#15,	r15	;#0x000f
  TXByte  = asciiCode[TXByte];
    f9a8:	59 4f 1c fb 	mov.b	-1252(r15),r9	;0xfb1c(r15)
    f9ac:	89 11       	sxt	r9		
    f9ae:	82 49 2e 02 	mov	r9,	&0x022e	
  cksum = cksum + TXByte;
  Transmit();                                           // Send
    f9b2:	b0 12 04 f9 	call	#0xf904	

  TXByte = (ADCValue >> 4) & 0x000F;
    f9b6:	1f 42 30 02 	mov	&0x0230,r15	
    f9ba:	12 c3       	clrc			
    f9bc:	0f 10       	rrc	r15		
    f9be:	0f 11       	rra	r15		
    f9c0:	0f 11       	rra	r15		
    f9c2:	0f 11       	rra	r15		
    f9c4:	3f f0 0f 00 	and	#15,	r15	;#0x000f
  TXByte  = asciiCode[TXByte];
    f9c8:	5a 4f 1c fb 	mov.b	-1252(r15),r10	;0xfb1c(r15)
    f9cc:	8a 11       	sxt	r10		
    f9ce:	82 4a 2e 02 	mov	r10,	&0x022e	
  cksum = cksum + TXByte;
  Transmit();                                           // Send
    f9d2:	b0 12 04 f9 	call	#0xf904	

  TXByte = ADCValue & 0x000F;
    f9d6:	1f 42 30 02 	mov	&0x0230,r15	
    f9da:	3f f0 0f 00 	and	#15,	r15	;#0x000f
  TXByte  = asciiCode[TXByte];
    f9de:	5f 4f 1c fb 	mov.b	-1252(r15),r15	;0xfb1c(r15)
    f9e2:	8f 11       	sxt	r15		
    f9e4:	82 4f 2e 02 	mov	r15,	&0x022e	
  /*************************************************************/  
  // Transmitir el valor del ADC
  /*************************************************************/
  TXByte = (ADCValue>>12) & 0x000F;
  TXByte  = asciiCode[TXByte];
  cksum = cksum + TXByte;
    f9e8:	0b 5f       	add	r15,	r11	
  Transmit();                                           // Send

  TXByte = (ADCValue>>8) & 0x000F;
  TXByte  = asciiCode[TXByte];
  cksum = cksum + TXByte;
    f9ea:	3b 50 10 01 	add	#272,	r11	;#0x0110
  Transmit();                                           // Send

  TXByte = (ADCValue >> 4) & 0x000F;
  TXByte  = asciiCode[TXByte];
  cksum = cksum + TXByte;
    f9ee:	0b 59       	add	r9,	r11	
  Transmit();                                           // Send

  TXByte = ADCValue & 0x000F;
  TXByte  = asciiCode[TXByte];
  cksum = cksum + TXByte;
    f9f0:	0b 5a       	add	r10,	r11	
  Transmit();                                           // Send
    f9f2:	b0 12 04 f9 	call	#0xf904	

  /*************************************************************/  
  // Transmitir el cksum
  /*************************************************************/  

  TXByte = (cksum >> 4) & 0x000F;
    f9f6:	0f 4b       	mov	r11,	r15	
    f9f8:	12 c3       	clrc			
    f9fa:	0f 10       	rrc	r15		
    f9fc:	0f 11       	rra	r15		
    f9fe:	0f 11       	rra	r15		
    fa00:	0f 11       	rra	r15		
    fa02:	3f f0 0f 00 	and	#15,	r15	;#0x000f
  TXByte  = asciiCode[TXByte];
    fa06:	3a 40 2e 02 	mov	#558,	r10	;#0x022e
    fa0a:	da 4f 1c fb 	mov.b	-1252(r15),0(r10)	;0xfb1c(r15), 0x0000(r10)
    fa0e:	00 00 
    fa10:	92 11 2e 02 	sxt	&0x022e	
  Transmit();                                           // Send
    fa14:	b0 12 04 f9 	call	#0xf904	

  TXByte = cksum & 0x000F;
    fa18:	3b f0 0f 00 	and	#15,	r11	;#0x000f
  TXByte  = asciiCode[TXByte];
    fa1c:	da 4b 1c fb 	mov.b	-1252(r11),0(r10)	;0xfb1c(r11), 0x0000(r10)
    fa20:	00 00 
    fa22:	92 11 2e 02 	sxt	&0x022e	
  Transmit();                                           // Send
    fa26:	b0 12 04 f9 	call	#0xf904	

  /*************************************************************/  
   // Transmitir Fin de Mensaje '!'
  /*************************************************************/  
   TXByte = '!';
    fa2a:	b2 40 21 00 	mov	#33,	&0x022e	;#0x0021
    fa2e:	2e 02 
   Transmit();
    fa30:	b0 12 04 f9 	call	#0xf904	
}
    fa34:	39 41       	pop	r9		
    fa36:	3a 41       	pop	r10		
    fa38:	3b 41       	pop	r11		
    fa3a:	30 41       	ret			

0000fa3c <setVlo>:
 
void setVlo (){
  BCSCTL1 |= DIVA_3;                        // ACLK/2
    fa3c:	f2 d0 30 00 	bis.b	#48,	&0x0057	;#0x0030
    fa40:	57 00 
  BCSCTL3 |= LFXT1S_2;                      // ACLK = VLO
    fa42:	f2 d0 20 00 	bis.b	#32,	&0x0053	;#0x0020
    fa46:	53 00 
  WDTCTL = WDT_ADLY_1000;                   // Interval timer
    fa48:	b2 40 1c 5a 	mov	#23068,	&0x0120	;#0x5a1c
    fa4c:	20 01 
  IE1 |= WDTIE;                             // Enable WDT interrupt
    fa4e:	d2 d3 00 00 	bis.b	#1,	&0x0000	;r3 As==01
}
    fa52:	30 41       	ret			

0000fa54 <delay_ms>:

// This function simply performs a software delay, hard from efficient but it's practical in this case.
void delay_ms(unsigned int ms ) { 

	unsigned int i;
	for (i = 0; i <= ms; i++) { 
    fa54:	0e 43       	clr	r14		
// Make sure your < and = has no space in between (the syntax parser seems to be messing things up)
		__delay_cycles(500); 
    fa56:	3d 40 a6 00 	mov	#166,	r13	;#0x00a6
    fa5a:	1d 83       	dec	r13		
    fa5c:	fe 23       	jnz	$-2      	;abs 0xfa5a

// This function simply performs a software delay, hard from efficient but it's practical in this case.
void delay_ms(unsigned int ms ) { 

	unsigned int i;
	for (i = 0; i <= ms; i++) { 
    fa5e:	1e 53       	inc	r14		
    fa60:	0f 9e       	cmp	r14,	r15	
    fa62:	f9 2f       	jc	$-12     	;abs 0xfa56
// Make sure your < and = has no space in between (the syntax parser seems to be messing things up)
		__delay_cycles(500); 
// This should be dependent on clock speed... but what the hell, even the loop itself should be taken into account...
	}
}
    fa64:	30 41       	ret			

0000fa66 <ConfigureAdcTempSensor>:

/* Configure ADC Temp Sensor Channel */
void ConfigureAdcTempSensor(void)
{
  unsigned char i;
  ADC10CTL1 = INCH_10 + ADC10DIV_3;         // Temp Sensor ADC10CLK/4
    fa66:	b2 40 60 a0 	mov	#-24480,&0x01b2	;#0xa060
    fa6a:	b2 01 
  ADC10CTL0 = SREF_1 + ADC10SHT_3 + REFON + ADC10ON + ADC10IE;
    fa6c:	b2 40 38 38 	mov	#14392,	&0x01b0	;#0x3838
    fa70:	b0 01 
  __delay_cycles(1000);                     // Wait for ADC Ref to settle
    fa72:	03 43       	nop			
    fa74:	03 43       	nop			
    fa76:	3f 40 4c 01 	mov	#332,	r15	;#0x014c
    fa7a:	1f 83       	dec	r15		
    fa7c:	fe 23       	jnz	$-2      	;abs 0xfa7a

  ADC10CTL0 |= ENC + ADC10SC;               // Sampling and conversion start
    fa7e:	b2 d0 03 00 	bis	#3,	&0x01b0	;#0x0003
    fa82:	b0 01 
  __bis_SR_register(CPUOFF + GIE);          // LPM0 with interrupts enabled
    fa84:	32 d0 18 00 	bis	#24,	r2	;#0x0018
  tempCalibrated = ADC10MEM;
    fa88:	1e 42 b4 01 	mov	&0x01b4,r14	
    fa8c:	82 4e 02 02 	mov	r14,	&0x0202	
    fa90:	82 43 04 02 	mov	#0,	&0x0204	;r3 As==00
    fa94:	3f 40 0c 02 	mov	#524,	r15	;#0x020c
  for (i=0; i < 8; i++)
    tempMeasured[i] = tempCalibrated;
    fa98:	8f 4e 00 00 	mov	r14,	0(r15)	;0x0000(r15)
    fa9c:	8f 43 02 00 	mov	#0,	2(r15)	;r3 As==00, 0x0002(r15)
    faa0:	2f 52       	add	#4,	r15	;r2 As==10
  __delay_cycles(1000);                     // Wait for ADC Ref to settle

  ADC10CTL0 |= ENC + ADC10SC;               // Sampling and conversion start
  __bis_SR_register(CPUOFF + GIE);          // LPM0 with interrupts enabled
  tempCalibrated = ADC10MEM;
  for (i=0; i < 8; i++)
    faa2:	3f 90 2c 02 	cmp	#556,	r15	;#0x022c
    faa6:	f8 23       	jnz	$-14     	;abs 0xfa98
    tempMeasured[i] = tempCalibrated;
  tempAverage = tempCalibrated;
    faa8:	82 4e 06 02 	mov	r14,	&0x0206	
    faac:	82 43 08 02 	mov	#0,	&0x0208	;r3 As==00
}
    fab0:	30 41       	ret			

0000fab2 <watchdog_timer>:
  }
}
 
void setClockTrans()
{
  BCSCTL1 = CALBC1_1MHZ;           // Set range
    fab2:	d2 42 ff 10 	mov.b	&0x10ff,&0x0057	
    fab6:	57 00 
  DCOCTL = CALDCO_1MHZ;            // SMCLK = DCO = 1MHz
    fab8:	d2 42 fe 10 	mov.b	&0x10fe,&0x0056	
    fabc:	56 00 
}

interrupt (WDT_VECTOR) watchdog_timer (void)
{
   setClockTrans();
  _BIC_SR_IRQ(LPM3_bits);                   // Clear LPM3 bits from 0(SR)
    fabe:	b1 c0 d0 00 	bic	#208,	0(r1)	;#0x00d0, 0x0000(r1)
    fac2:	00 00 
}
    fac4:	00 13       	reti			

0000fac6 <ADC10_ISR>:
// -------- CCS & IAR convention
//#pragma vector=ADC10_VECTOR
//__interrupt void ADC10_ISR (void)
interrupt (ADC10_VECTOR) ADC10_ISR(void)
{
  __bic_SR_register_on_exit(CPUOFF);        // Return to active mode
    fac6:	b1 c0 10 00 	bic	#16,	0(r1)	;#0x0010, 0x0000(r1)
    faca:	00 00 
}
    facc:	00 13       	reti			

0000face <Timer_A>:

// Timer A0 interrupt service routine
//#pragma vector=TIMERA0_VECTOR
interrupt (TIMERA0_VECTOR) Timer_A (void)
{
    face:	0f 12       	push	r15		
    fad0:	0e 12       	push	r14		
    fad2:	0d 12       	push	r13		
  CCR0 += Bitime;     // Add Offset to CCR0  
    fad4:	b2 50 68 00 	add	#104,	&0x0172	;#0x0068
    fad8:	72 01 
  if ( BitCnt == 0)     // If all bits TXed, disable interrupt
    fada:	5f 42 2c 02 	mov.b	&0x022c,r15	
    fade:	4f 93       	tst.b	r15		
    fae0:	16 24       	jz	$+46     	;abs 0xfb0e
    CCTL0 &= ~ CCIE ;
  else
  {
    CCTL0 |=  OUTMOD2;                    // TX Space
    fae2:	b2 d0 80 00 	bis	#128,	&0x0162	;#0x0080
    fae6:	62 01 
    if (TXByte & 0x01)
    fae8:	1e 42 2e 02 	mov	&0x022e,r14	
    faec:	1e b3       	bit	#1,	r14	;r3 As==01
    faee:	0b 20       	jnz	$+24     	;abs 0xfb06
      CCTL0 &= ~ OUTMOD2;                   // TX Mark
    TXByte = TXByte >> 1;
    faf0:	12 c3       	clrc			
    faf2:	0e 10       	rrc	r14		
    faf4:	82 4e 2e 02 	mov	r14,	&0x022e	
    BitCnt --;
    faf8:	7f 53       	add.b	#-1,	r15	;r3 As==11
    fafa:	c2 4f 2c 02 	mov.b	r15,	&0x022c	
  }
}
    fafe:	3d 41       	pop	r13		
    fb00:	3e 41       	pop	r14		
    fb02:	3f 41       	pop	r15		
    fb04:	00 13       	reti			
    CCTL0 &= ~ CCIE ;
  else
  {
    CCTL0 |=  OUTMOD2;                    // TX Space
    if (TXByte & 0x01)
      CCTL0 &= ~ OUTMOD2;                   // TX Mark
    fb06:	b2 f0 7f ff 	and	#-129,	&0x0162	;#0xff7f
    fb0a:	62 01 
    fb0c:	f1 3f       	jmp	$-28     	;abs 0xfaf0
//#pragma vector=TIMERA0_VECTOR
interrupt (TIMERA0_VECTOR) Timer_A (void)
{
  CCR0 += Bitime;     // Add Offset to CCR0  
  if ( BitCnt == 0)     // If all bits TXed, disable interrupt
    CCTL0 &= ~ CCIE ;
    fb0e:	b2 f0 ef ff 	and	#-17,	&0x0162	;#0xffef
    fb12:	62 01 
    if (TXByte & 0x01)
      CCTL0 &= ~ OUTMOD2;                   // TX Mark
    TXByte = TXByte >> 1;
    BitCnt --;
  }
}
    fb14:	3d 41       	pop	r13		
    fb16:	3e 41       	pop	r14		
    fb18:	3f 41       	pop	r15		
    fb1a:	00 13       	reti			

0000fb1c <asciiCode>:
    fb1c:	30 31 32 33 34 35 36 37 38 39 41 42 43 44 45 46     0123456789ABCDEF

0000fb2c <_unexpected_>:
    fb2c:	00 13       	reti			

Disassembly of section .vectors:

0000ffe0 <__ivtbl_16>:
    ffe0:	f2 f8 f2 f8 f2 f8 f2 f8 f2 f8 c6 fa f2 f8 f2 f8     ................
    fff0:	f2 f8 ce fa b2 fa f2 f8 f2 f8 f2 f8 f2 f8 00 f8     ................
