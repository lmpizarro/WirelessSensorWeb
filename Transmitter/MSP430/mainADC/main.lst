
main.elf:     file format elf32-msp430

SYMBOL TABLE:
0000f800 l    d  .text	00000000 .text
00000200 l    d  .bss	00000000 .bss
0000ffe0 l    d  .vectors	00000000 .vectors
00000000 l    d  .debug_aranges	00000000 .debug_aranges
00000000 l    d  .debug_pubnames	00000000 .debug_pubnames
00000000 l    d  .debug_info	00000000 .debug_info
00000000 l    d  .debug_abbrev	00000000 .debug_abbrev
00000000 l    d  .debug_line	00000000 .debug_line
00000000 l    d  .debug_frame	00000000 .debug_frame
00000000 l    d  .debug_str	00000000 .debug_str
00000000 l    d  .debug_loc	00000000 .debug_loc
00000000 l    d  .debug_pubtypes	00000000 .debug_pubtypes
00000000 l    d  .debug_ranges	00000000 .debug_ranges
00000000 l    df *ABS*	00000000 main.c
0000fae4 l     O .text	00000010 asciiCode
0000f8cc l       .text	00000000 __br_unexpected_
0000007c g       *ABS*	00000000 __USISR
00000057 g       *ABS*	00000000 __BCSCTL1
00000174 g       *ABS*	00000000 __TACCR1
00000000 g       *ABS*	00000000 __data_size
0000f8cc  w      .text	00000000 __isr_14
0000fa8e g     F .text	00000008 ADC10_ISR
0000007a g       *ABS*	00000000 __USICKCTL
00000128 g       *ABS*	00000000 __FCTL1
00000024 g       *ABS*	00000000 __P1IES
0000f8cc  w      .text	00000000 __isr_4
00000002 g       *ABS*	00000000 __IFG1
0000f91e g     F .text	000000f8 TransmitADCValue
0000012e g       *ABS*	00000000 __TAIV
00000000 g       .vectors	00000000 _efartext
0000002b g       *ABS*	00000000 __P2IFG
0000fa16 g     F .text	00000018 setVlo
0000faf6 g       *ABS*	00000000 _etext
0000fa96 g     F .text	0000004e Timer_A
00000034 g       *ABS*	00000000 __bss_size
00000078 g       *ABS*	00000000 __USICTL
0000f8c6  w      .text	00000000 __stop_progExec__
0000002d g       *ABS*	00000000 __P2IE
0000f8cc  w      .text	00000000 __isr_11
00000025 g       *ABS*	00000000 __P1IE
00000049 g       *ABS*	00000000 __ADC10DTC1
0000fa8e g       .text	00000000 __isr_5
0000faf6 g       *ABS*	00000000 __data_load_start
0000f8cc g       .text	00000000 __dtors_end
00000053 g       *ABS*	00000000 __BCSCTL3
000001bc g       *ABS*	00000000 __ADC10SA
0000007a g       *ABS*	00000000 __USICCTL
0000f8cc  w      .text	00000000 __isr_2
0000f8de g     F .text	00000040 Transmit
00000160 g       *ABS*	00000000 __TACTL
0000012c g       *ABS*	00000000 __FCTL3
0000fa7a g       .text	00000000 __isr_10
0000002e g       *ABS*	00000000 __P2SEL
00000202 g     O .bss	00000004 tempCalibrated
00000023 g       *ABS*	00000000 __P1IFG
0000004a g       *ABS*	00000000 __ADC10AE0
00000172 g       *ABS*	00000000 __TACCR0
00000056 g       *ABS*	00000000 __DCOCTL
0000f8cc  w      .text	00000000 __isr_7
0000ffe0 g     O .vectors	00000020 __ivtbl_16
00000028 g       *ABS*	00000000 __P2IN
00000206 g     O .bss	00000004 tempAverage
0000fa2e g     F .text	0000004c ConfigureAdcTempSensor
000001b4 g       *ABS*	00000000 __ADC10MEM
0000f8cc  w      .text	00000000 __isr_0
00000029 g       *ABS*	00000000 __P2OUT
0000012a g       *ABS*	00000000 __FCTL2
0000f824  w      .text	00000000 __do_clear_bss
00000021 g       *ABS*	00000000 __P1OUT
0000002c g       *ABS*	00000000 __P2IES
00000026 g       *ABS*	00000000 __P1SEL
0000020a g     O .bss	00000001 ADCDone
0000020c g     O .bss	00000020 tempMeasured
00000079 g       *ABS*	00000000 __USICTL1
00000200 g     O .bss	00000001 tempMeasuredPosition
00000027 g       *ABS*	00000000 __P1REN
0000faf4  w      .text	00000000 _unexpected_
0000f8cc  w      .text	00000000 __isr_8
0000f8cc  w      .text	00000000 __isr_3
0000f800  w      .text	00000000 _reset_vector__
0000fa7a g     F .text	00000014 watchdog_timer
0000f8cc g       .text	00000000 __ctors_start
0000f8cc  w      .text	00000000 __isr_12
0000f80e  w      .text	00000000 __do_copy_data
00000200 g       .bss	00000000 __bss_start
0000022c g     O .bss	00000001 BitCnt
0000f838 g     F .text	0000008e main
0000022e g     O .bss	00000002 TXByte
00000230 g     O .bss	00000002 uartUpdateTimer
0000f8cc  w      .text	00000000 __isr_13
00000170 g       *ABS*	00000000 __TAR
00000162 g       *ABS*	00000000 __TACCTL0
00010000 g       .vectors	00000000 _vectors_end
0000002a g       *ABS*	00000000 __P2DIR
0000002f g       *ABS*	00000000 __P2REN
0000007d g       *ABS*	00000000 __USISRH
00000232 g     O .bss	00000002 ADCValue
000001b0 g       *ABS*	00000000 __ADC10CTL0
0000fa96 g       .text	00000000 __isr_9
000010fe g       *ABS*	00000000 __CALDCO_1MHZ
0000f800  w      .text	00000000 __init_stack
0000f8cc g       .text	00000000 __dtors_start
0000f8cc  w      .text	00000000 __isr_6
0000f8cc g       .text	00000000 __ctors_end
00000280 g       *ABS*	00000000 __stack
0000f8cc  w      .text	00000000 __isr_1
00000200 g       .text	00000000 _edata
00000234 g       .bss	00000000 _end
0000007b g       *ABS*	00000000 __USICNT
00000048 g       *ABS*	00000000 __ADC10DTC0
000001b2 g       *ABS*	00000000 __ADC10CTL1
00000058 g       *ABS*	00000000 __BCSCTL2
0000f8c6  w      .text	00000000 _endless_loop__
00000022 g       *ABS*	00000000 __P1DIR
00000164 g       *ABS*	00000000 __TACCTL1
000010ff g       *ABS*	00000000 __CALBC1_1MHZ
0000f804  w      .text	00000000 __low_level_init
0000f8d0 g     F .text	0000000e setClockTrans
00000200 g       .text	00000000 __data_start
00000120 g       *ABS*	00000000 __WDTCTL
00000000 g       *ABS*	00000000 __IE1
00000078 g       *ABS*	00000000 __USICTL0
00000020 g       *ABS*	00000000 __P1IN
0000007c g       *ABS*	00000000 __USISRL



Disassembly of section .text:

0000f800 <__init_stack>:
    f800:	31 40 80 02 	mov	#640,	r1	;#0x0280

0000f804 <__low_level_init>:
    f804:	15 42 20 01 	mov	&0x0120,r5	
    f808:	75 f3       	and.b	#-1,	r5	;r3 As==11
    f80a:	35 d0 08 5a 	bis	#23048,	r5	;#0x5a08

0000f80e <__do_copy_data>:
    f80e:	3f 40 00 00 	mov	#0,	r15	;#0x0000
    f812:	0f 93       	tst	r15		
    f814:	07 24       	jz	$+16     	;abs 0xf824
    f816:	82 45 20 01 	mov	r5,	&0x0120	
    f81a:	2f 83       	decd	r15		
    f81c:	9f 4f f6 fa 	mov	-1290(r15),512(r15);0xfaf6(r15), 0x0200(r15)
    f820:	00 02 
    f822:	f9 23       	jnz	$-12     	;abs 0xf816

0000f824 <__do_clear_bss>:
    f824:	3f 40 34 00 	mov	#52,	r15	;#0x0034
    f828:	0f 93       	tst	r15		
    f82a:	06 24       	jz	$+14     	;abs 0xf838
    f82c:	82 45 20 01 	mov	r5,	&0x0120	
    f830:	1f 83       	dec	r15		
    f832:	cf 43 00 02 	mov.b	#0,	512(r15);r3 As==00, 0x0200(r15)
    f836:	fa 23       	jnz	$-10     	;abs 0xf82c

0000f838 <main>:

int main (){

  unsigned char i;

  WDTCTL = WDTPW + WDTHOLD;        // Stop WDT
    f838:	b2 40 80 5a 	mov	#23168,	&0x0120	;#0x5a80
    f83c:	20 01 
}

 
void setClockTrans()
{
  BCSCTL1 = CALBC1_1MHZ;           // Set range
    f83e:	d2 42 ff 10 	mov.b	&0x10ff,&0x0057	
    f842:	57 00 
  DCOCTL = CALDCO_1MHZ;            // SMCLK = DCO = 1MHz
    f844:	d2 42 fe 10 	mov.b	&0x10fe,&0x0056	
    f848:	56 00 
  unsigned char i;

  WDTCTL = WDTPW + WDTHOLD;        // Stop WDT
  setClockTrans();

  __bis_SR_register(GIE);        // interrupts enabled 
    f84a:	32 d2       	eint			

  P1SEL |= TXD;                              //
    f84c:	e2 d3 26 00 	bis.b	#2,	&0x0026	;r3 As==10
  P1DIR |= TXD;                              //
    f850:	e2 d3 22 00 	bis.b	#2,	&0x0022	;r3 As==10

  ConfigureAdcTempSensor();
    f854:	b0 12 2e fa 	call	#0xfa2e	

  __enable_interrupt();                     // Enable interrupts.
    f858:	32 d2       	eint			

  while(1)
  {  
 
     ADC10CTL0 |= ENC + ADC10SC;             // Sampling and conversion start
    f85a:	b2 d0 03 00 	bis	#3,	&0x01b0	;#0x0003
    f85e:	b0 01 
    __bis_SR_register(CPUOFF + GIE);        // LPM0 with interrupts enabled
    f860:	32 d0 18 00 	bis	#24,	r2	;#0x0018

    /* Moving average filter out of 8 values to somewhat stabilize sampled ADC */
    tempMeasured[tempMeasuredPosition++] = ADC10MEM;
    f864:	5e 42 00 02 	mov.b	&0x0200,r14	
    f868:	4f 4e       	mov.b	r14,	r15	
    f86a:	0f 5f       	rla	r15		
    f86c:	0f 5f       	rla	r15		
    f86e:	3f 50 0c 02 	add	#524,	r15	;#0x020c
    f872:	9f 42 b4 01 	mov	&0x01b4,0(r15)	;0x0000(r15)
    f876:	00 00 
    f878:	8f 43 02 00 	mov	#0,	2(r15)	;r3 As==00, 0x0002(r15)
    f87c:	4f 4e       	mov.b	r14,	r15	
    f87e:	5f 53       	inc.b	r15		
    f880:	c2 4f 00 02 	mov.b	r15,	&0x0200	
    if (tempMeasuredPosition == 8)
    f884:	7f 92       	cmp.b	#8,	r15	;r2 As==11
    f886:	1c 24       	jz	$+58     	;abs 0xf8c0
      tempMeasuredPosition = 0;
    tempAverage = 0;
    f888:	3d 40 0c 02 	mov	#524,	r13	;#0x020c
void ConfigureAdcTempSensor(void);


#include "transmitADCValue.c"

int main (){
    f88c:	0e 43       	clr	r14		
    f88e:	0f 43       	clr	r15		
    tempMeasured[tempMeasuredPosition++] = ADC10MEM;
    if (tempMeasuredPosition == 8)
      tempMeasuredPosition = 0;
    tempAverage = 0;
    for (i = 0; i < 8; i++)
      tempAverage += tempMeasured[i];
    f890:	3e 5d       	add	@r13+,	r14	
    f892:	3f 6d       	addc	@r13+,	r15	
    /* Moving average filter out of 8 values to somewhat stabilize sampled ADC */
    tempMeasured[tempMeasuredPosition++] = ADC10MEM;
    if (tempMeasuredPosition == 8)
      tempMeasuredPosition = 0;
    tempAverage = 0;
    for (i = 0; i < 8; i++)
    f894:	3d 90 2c 02 	cmp	#556,	r13	;#0x022c
    f898:	fb 23       	jnz	$-8      	;abs 0xf890
      tempAverage += tempMeasured[i];
    tempAverage >>= 3;
    f89a:	0f 11       	rra	r15		
    f89c:	0e 10       	rrc	r14		
    f89e:	0f 11       	rra	r15		
    f8a0:	0e 10       	rrc	r14		
    f8a2:	0f 11       	rra	r15		
    f8a4:	0e 10       	rrc	r14		
    f8a6:	82 4e 06 02 	mov	r14,	&0x0206	
    f8aa:	82 4f 08 02 	mov	r15,	&0x0208	

    ADCValue = tempAverage;
    f8ae:	82 4e 32 02 	mov	r14,	&0x0232	
    TransmitADCValue ();    
    f8b2:	b0 12 1e f9 	call	#0xf91e	
 
    //TXByte = 65;
    //Transmit(); 
    setVlo ();
    f8b6:	b0 12 16 fa 	call	#0xfa16	
    _BIS_SR(LPM3_bits + GIE);               // Enter LPM3
    f8ba:	32 d0 d8 00 	bis	#216,	r2	;#0x00d8
    f8be:	cd 3f       	jmp	$-100    	;abs 0xf85a
    __bis_SR_register(CPUOFF + GIE);        // LPM0 with interrupts enabled

    /* Moving average filter out of 8 values to somewhat stabilize sampled ADC */
    tempMeasured[tempMeasuredPosition++] = ADC10MEM;
    if (tempMeasuredPosition == 8)
      tempMeasuredPosition = 0;
    f8c0:	c2 43 00 02 	mov.b	#0,	&0x0200	;r3 As==00
    f8c4:	e1 3f       	jmp	$-60     	;abs 0xf888

0000f8c6 <__stop_progExec__>:
    f8c6:	32 d0 f0 00 	bis	#240,	r2	;#0x00f0
    f8ca:	fd 3f       	jmp	$-4      	;abs 0xf8c6

0000f8cc <__ctors_end>:
    f8cc:	30 40 f4 fa 	br	#0xfaf4	

0000f8d0 <setClockTrans>:
}

 
void setClockTrans()
{
  BCSCTL1 = CALBC1_1MHZ;           // Set range
    f8d0:	d2 42 ff 10 	mov.b	&0x10ff,&0x0057	
    f8d4:	57 00 
  DCOCTL = CALDCO_1MHZ;            // SMCLK = DCO = 1MHz
    f8d6:	d2 42 fe 10 	mov.b	&0x10fe,&0x0056	
    f8da:	56 00 
}
    f8dc:	30 41       	ret			

0000f8de <Transmit>:


// Function Transmits Character from TXByte 
void Transmit()
{ 
  CCTL0 = OUT;                               // TXD Idle as Mark
    f8de:	a2 42 62 01 	mov	#4,	&0x0162	;r2 As==10
  TACTL = TASSEL_2 + MC_2;               // SMCLK, continuous mode
    f8e2:	b2 40 20 02 	mov	#544,	&0x0160	;#0x0220
    f8e6:	60 01 
 
  BitCnt = 0xA;                       // Load Bit counter, 8 bits + ST/SP
    f8e8:	f2 40 0a 00 	mov.b	#10,	&0x022c	;#0x000a
    f8ec:	2c 02 
  CCR0 = TAR;
    f8ee:	92 42 70 01 	mov	&0x0170,&0x0172	
    f8f2:	72 01 
   
  CCR0 += Bitime;                  // Set time till first bit
    f8f4:	b2 50 68 00 	add	#104,	&0x0172	;#0x0068
    f8f8:	72 01 
  TXByte |= 0x100;                 // Add stop bit to TXByte (which is logical 1)
  TXByte = TXByte << 1;            // Add start bit (which is logical 0)
    f8fa:	1f 42 2e 02 	mov	&0x022e,r15	
    f8fe:	3f d0 00 01 	bis	#256,	r15	;#0x0100
    f902:	0f 5f       	rla	r15		
    f904:	82 4f 2e 02 	mov	r15,	&0x022e	
   
  CCTL0 =  CCIS0 + OUTMOD0 + CCIE; // Set signal, intial value, enable interrupts
    f908:	b2 40 30 10 	mov	#4144,	&0x0162	;#0x1030
    f90c:	62 01 
  while ( CCTL0 & CCIE );          // Wait for TX completion
    f90e:	b2 b0 10 00 	bit	#16,	&0x0162	;#0x0010
    f912:	62 01 
    f914:	fc 23       	jnz	$-6      	;abs 0xf90e
  TACTL = TASSEL_2;             // SMCLK, timer off (for power consumption)
    f916:	b2 40 00 02 	mov	#512,	&0x0160	;#0x0200
    f91a:	60 01 
}
    f91c:	30 41       	ret			

0000f91e <TransmitADCValue>:

#define SensorId     12
#define codFunc       3


void TransmitADCValue (){
    f91e:	0b 12       	push	r11		
    f920:	0a 12       	push	r10		
    f922:	09 12       	push	r9		
  unsigned int cksum = 0;

  /*************************************************************/  
  // Transmitir Comienzo  de Mensaje ':'
  /*************************************************************/  
   TXByte = ':';
    f924:	b2 40 3a 00 	mov	#58,	&0x022e	;#0x003a
    f928:	2e 02 
   cksum = cksum + TXByte;
   Transmit();
    f92a:	b0 12 de f8 	call	#0xf8de	
  /*************************************************************/  
  //  Transmitir el SensorId
  /*************************************************************/  

   TXByte = (SensorId >> 4) & 0x000F;
   TXByte  = asciiCode[TXByte];
    f92e:	b2 40 30 00 	mov	#48,	&0x022e	;#0x0030
    f932:	2e 02 
   cksum = cksum + TXByte;
   Transmit();                                           // Send
    f934:	b0 12 de f8 	call	#0xf8de	


  TXByte = SensorId & 0x000F;
  TXByte  = asciiCode[TXByte];
    f938:	b2 40 43 00 	mov	#67,	&0x022e	;#0x0043
    f93c:	2e 02 
  cksum = cksum + TXByte;
  Transmit();                                           // Send
    f93e:	b0 12 de f8 	call	#0xf8de	

  /*************************************************************/  
  // Transmitir el codFunc 
  /*************************************************************/  
  TXByte = (codFunc >> 4) & 0x000F;
  TXByte  = asciiCode[TXByte];
    f942:	b2 40 30 00 	mov	#48,	&0x022e	;#0x0030
    f946:	2e 02 
  cksum = cksum + TXByte;
  Transmit();                                           // Send
    f948:	b0 12 de f8 	call	#0xf8de	


  TXByte = codFunc & 0x000F;
  TXByte  = asciiCode[TXByte];
    f94c:	b2 40 33 00 	mov	#51,	&0x022e	;#0x0033
    f950:	2e 02 
  cksum = cksum + TXByte;
  Transmit();                                           // Send
    f952:	b0 12 de f8 	call	#0xf8de	


  /*************************************************************/  
  // Transmitir el valor del ADC
  /*************************************************************/
  TXByte = (ADCValue>>12) & 0x000F;
    f956:	1f 42 32 02 	mov	&0x0232,r15	
    f95a:	8f 10       	swpb	r15		
    f95c:	3f f0 ff 00 	and	#255,	r15	;#0x00ff
    f960:	12 c3       	clrc			
    f962:	0f 10       	rrc	r15		
    f964:	0f 11       	rra	r15		
    f966:	0f 11       	rra	r15		
    f968:	0f 11       	rra	r15		
  TXByte  = asciiCode[TXByte];
    f96a:	5b 4f e4 fa 	mov.b	-1308(r15),r11	;0xfae4(r15)
    f96e:	8b 11       	sxt	r11		
    f970:	82 4b 2e 02 	mov	r11,	&0x022e	
  cksum = cksum + TXByte;
  Transmit();                                           // Send
    f974:	b0 12 de f8 	call	#0xf8de	

  TXByte = (ADCValue>>8) & 0x000F;
    f978:	1f 42 32 02 	mov	&0x0232,r15	
    f97c:	8f 10       	swpb	r15		
    f97e:	3f f0 0f 00 	and	#15,	r15	;#0x000f
  TXByte  = asciiCode[TXByte];
    f982:	59 4f e4 fa 	mov.b	-1308(r15),r9	;0xfae4(r15)
    f986:	89 11       	sxt	r9		
    f988:	82 49 2e 02 	mov	r9,	&0x022e	
  cksum = cksum + TXByte;
  Transmit();                                           // Send
    f98c:	b0 12 de f8 	call	#0xf8de	

  TXByte = (ADCValue >> 4) & 0x000F;
    f990:	1f 42 32 02 	mov	&0x0232,r15	
    f994:	12 c3       	clrc			
    f996:	0f 10       	rrc	r15		
    f998:	0f 11       	rra	r15		
    f99a:	0f 11       	rra	r15		
    f99c:	0f 11       	rra	r15		
    f99e:	3f f0 0f 00 	and	#15,	r15	;#0x000f
  TXByte  = asciiCode[TXByte];
    f9a2:	5a 4f e4 fa 	mov.b	-1308(r15),r10	;0xfae4(r15)
    f9a6:	8a 11       	sxt	r10		
    f9a8:	82 4a 2e 02 	mov	r10,	&0x022e	
  cksum = cksum + TXByte;
  Transmit();                                           // Send
    f9ac:	b0 12 de f8 	call	#0xf8de	

  TXByte = ADCValue & 0x000F;
    f9b0:	1f 42 32 02 	mov	&0x0232,r15	
    f9b4:	3f f0 0f 00 	and	#15,	r15	;#0x000f
  TXByte  = asciiCode[TXByte];
    f9b8:	5f 4f e4 fa 	mov.b	-1308(r15),r15	;0xfae4(r15)
    f9bc:	8f 11       	sxt	r15		
    f9be:	82 4f 2e 02 	mov	r15,	&0x022e	
  /*************************************************************/  
  // Transmitir el valor del ADC
  /*************************************************************/
  TXByte = (ADCValue>>12) & 0x000F;
  TXByte  = asciiCode[TXByte];
  cksum = cksum + TXByte;
    f9c2:	0b 5f       	add	r15,	r11	
  Transmit();                                           // Send

  TXByte = (ADCValue>>8) & 0x000F;
  TXByte  = asciiCode[TXByte];
  cksum = cksum + TXByte;
    f9c4:	3b 50 10 01 	add	#272,	r11	;#0x0110
  Transmit();                                           // Send

  TXByte = (ADCValue >> 4) & 0x000F;
  TXByte  = asciiCode[TXByte];
  cksum = cksum + TXByte;
    f9c8:	0b 59       	add	r9,	r11	
  Transmit();                                           // Send

  TXByte = ADCValue & 0x000F;
  TXByte  = asciiCode[TXByte];
  cksum = cksum + TXByte;
    f9ca:	0b 5a       	add	r10,	r11	
  Transmit();                                           // Send
    f9cc:	b0 12 de f8 	call	#0xf8de	

  /*************************************************************/  
  // Transmitir el cksum
  /*************************************************************/  

  TXByte = (cksum >> 4) & 0x000F;
    f9d0:	0f 4b       	mov	r11,	r15	
    f9d2:	12 c3       	clrc			
    f9d4:	0f 10       	rrc	r15		
    f9d6:	0f 11       	rra	r15		
    f9d8:	0f 11       	rra	r15		
    f9da:	0f 11       	rra	r15		
    f9dc:	3f f0 0f 00 	and	#15,	r15	;#0x000f
  TXByte  = asciiCode[TXByte];
    f9e0:	3a 40 2e 02 	mov	#558,	r10	;#0x022e
    f9e4:	da 4f e4 fa 	mov.b	-1308(r15),0(r10)	;0xfae4(r15), 0x0000(r10)
    f9e8:	00 00 
    f9ea:	92 11 2e 02 	sxt	&0x022e	
  Transmit();                                           // Send
    f9ee:	b0 12 de f8 	call	#0xf8de	

  TXByte = cksum & 0x000F;
    f9f2:	3b f0 0f 00 	and	#15,	r11	;#0x000f
  TXByte  = asciiCode[TXByte];
    f9f6:	da 4b e4 fa 	mov.b	-1308(r11),0(r10)	;0xfae4(r11), 0x0000(r10)
    f9fa:	00 00 
    f9fc:	92 11 2e 02 	sxt	&0x022e	
  Transmit();                                           // Send
    fa00:	b0 12 de f8 	call	#0xf8de	

  /*************************************************************/  
   // Transmitir Fin de Mensaje '!'
  /*************************************************************/  
   TXByte = '!';
    fa04:	b2 40 21 00 	mov	#33,	&0x022e	;#0x0021
    fa08:	2e 02 
   Transmit();
    fa0a:	b0 12 de f8 	call	#0xf8de	
}
    fa0e:	39 41       	pop	r9		
    fa10:	3a 41       	pop	r10		
    fa12:	3b 41       	pop	r11		
    fa14:	30 41       	ret			

0000fa16 <setVlo>:
 
void setVlo (){
  BCSCTL1 |= DIVA_3;                        // ACLK/2
    fa16:	f2 d0 30 00 	bis.b	#48,	&0x0057	;#0x0030
    fa1a:	57 00 
  BCSCTL3 |= LFXT1S_2;                      // ACLK = VLO
    fa1c:	f2 d0 20 00 	bis.b	#32,	&0x0053	;#0x0020
    fa20:	53 00 
  WDTCTL = WDT_ADLY_1000;                   // Interval timer
    fa22:	b2 40 1c 5a 	mov	#23068,	&0x0120	;#0x5a1c
    fa26:	20 01 
  IE1 |= WDTIE;                             // Enable WDT interrupt
    fa28:	d2 d3 00 00 	bis.b	#1,	&0x0000	;r3 As==01
}
    fa2c:	30 41       	ret			

0000fa2e <ConfigureAdcTempSensor>:

/* Configure ADC Temp Sensor Channel */
void ConfigureAdcTempSensor(void)
{
  unsigned char i;
  ADC10CTL1 = INCH_10 + ADC10DIV_3;         // Temp Sensor ADC10CLK/4
    fa2e:	b2 40 60 a0 	mov	#-24480,&0x01b2	;#0xa060
    fa32:	b2 01 
  ADC10CTL0 = SREF_1 + ADC10SHT_3 + REFON + ADC10ON + ADC10IE;
    fa34:	b2 40 38 38 	mov	#14392,	&0x01b0	;#0x3838
    fa38:	b0 01 
  __delay_cycles(1000);                     // Wait for ADC Ref to settle
    fa3a:	03 43       	nop			
    fa3c:	03 43       	nop			
    fa3e:	3f 40 4c 01 	mov	#332,	r15	;#0x014c
    fa42:	1f 83       	dec	r15		
    fa44:	fe 23       	jnz	$-2      	;abs 0xfa42

  ADC10CTL0 |= ENC + ADC10SC;               // Sampling and conversion start
    fa46:	b2 d0 03 00 	bis	#3,	&0x01b0	;#0x0003
    fa4a:	b0 01 
  __bis_SR_register(CPUOFF + GIE);          // LPM0 with interrupts enabled
    fa4c:	32 d0 18 00 	bis	#24,	r2	;#0x0018
  tempCalibrated = ADC10MEM;
    fa50:	1e 42 b4 01 	mov	&0x01b4,r14	
    fa54:	82 4e 02 02 	mov	r14,	&0x0202	
    fa58:	82 43 04 02 	mov	#0,	&0x0204	;r3 As==00
    fa5c:	3f 40 0c 02 	mov	#524,	r15	;#0x020c
  for (i=0; i < 8; i++)
    tempMeasured[i] = tempCalibrated;
    fa60:	8f 4e 00 00 	mov	r14,	0(r15)	;0x0000(r15)
    fa64:	8f 43 02 00 	mov	#0,	2(r15)	;r3 As==00, 0x0002(r15)
    fa68:	2f 52       	add	#4,	r15	;r2 As==10
  __delay_cycles(1000);                     // Wait for ADC Ref to settle

  ADC10CTL0 |= ENC + ADC10SC;               // Sampling and conversion start
  __bis_SR_register(CPUOFF + GIE);          // LPM0 with interrupts enabled
  tempCalibrated = ADC10MEM;
  for (i=0; i < 8; i++)
    fa6a:	3f 90 2c 02 	cmp	#556,	r15	;#0x022c
    fa6e:	f8 23       	jnz	$-14     	;abs 0xfa60
    tempMeasured[i] = tempCalibrated;
  tempAverage = tempCalibrated;
    fa70:	82 4e 06 02 	mov	r14,	&0x0206	
    fa74:	82 43 08 02 	mov	#0,	&0x0208	;r3 As==00
}
    fa78:	30 41       	ret			

0000fa7a <watchdog_timer>:
}

 
void setClockTrans()
{
  BCSCTL1 = CALBC1_1MHZ;           // Set range
    fa7a:	d2 42 ff 10 	mov.b	&0x10ff,&0x0057	
    fa7e:	57 00 
  DCOCTL = CALDCO_1MHZ;            // SMCLK = DCO = 1MHz
    fa80:	d2 42 fe 10 	mov.b	&0x10fe,&0x0056	
    fa84:	56 00 
}

interrupt (WDT_VECTOR) watchdog_timer (void)
{
  setClockTrans();
  _BIC_SR_IRQ(LPM3_bits);                   // Clear LPM3 bits from 0(SR)
    fa86:	b1 c0 d0 00 	bic	#208,	0(r1)	;#0x00d0, 0x0000(r1)
    fa8a:	00 00 
}
    fa8c:	00 13       	reti			

0000fa8e <ADC10_ISR>:
//#pragma vector=ADC10_VECTOR
//__interrupt void ADC10_ISR (void)
interrupt (ADC10_VECTOR) ADC10_ISR(void)
{

  __bic_SR_register_on_exit(CPUOFF);        // Return to active mode
    fa8e:	b1 c0 10 00 	bic	#16,	0(r1)	;#0x0010, 0x0000(r1)
    fa92:	00 00 

}
    fa94:	00 13       	reti			

0000fa96 <Timer_A>:

// Timer A0 interrupt service routine
//#pragma vector=TIMERA0_VECTOR
interrupt (TIMERA0_VECTOR) Timer_A (void)
{
    fa96:	0f 12       	push	r15		
    fa98:	0e 12       	push	r14		
    fa9a:	0d 12       	push	r13		
  CCR0 += Bitime;     // Add Offset to CCR0  
    fa9c:	b2 50 68 00 	add	#104,	&0x0172	;#0x0068
    faa0:	72 01 
  if ( BitCnt == 0)     // If all bits TXed, disable interrupt
    faa2:	5f 42 2c 02 	mov.b	&0x022c,r15	
    faa6:	4f 93       	tst.b	r15		
    faa8:	16 24       	jz	$+46     	;abs 0xfad6
    CCTL0 &= ~ CCIE ;
  else
  {
    CCTL0 |=  OUTMOD2;                    // TX Space
    faaa:	b2 d0 80 00 	bis	#128,	&0x0162	;#0x0080
    faae:	62 01 
    if (TXByte & 0x01)
    fab0:	1e 42 2e 02 	mov	&0x022e,r14	
    fab4:	1e b3       	bit	#1,	r14	;r3 As==01
    fab6:	0b 20       	jnz	$+24     	;abs 0xface
      CCTL0 &= ~ OUTMOD2;                   // TX Mark
    TXByte = TXByte >> 1;
    fab8:	12 c3       	clrc			
    faba:	0e 10       	rrc	r14		
    fabc:	82 4e 2e 02 	mov	r14,	&0x022e	
    BitCnt --;
    fac0:	7f 53       	add.b	#-1,	r15	;r3 As==11
    fac2:	c2 4f 2c 02 	mov.b	r15,	&0x022c	
  }
}
    fac6:	3d 41       	pop	r13		
    fac8:	3e 41       	pop	r14		
    faca:	3f 41       	pop	r15		
    facc:	00 13       	reti			
    CCTL0 &= ~ CCIE ;
  else
  {
    CCTL0 |=  OUTMOD2;                    // TX Space
    if (TXByte & 0x01)
      CCTL0 &= ~ OUTMOD2;                   // TX Mark
    face:	b2 f0 7f ff 	and	#-129,	&0x0162	;#0xff7f
    fad2:	62 01 
    fad4:	f1 3f       	jmp	$-28     	;abs 0xfab8
//#pragma vector=TIMERA0_VECTOR
interrupt (TIMERA0_VECTOR) Timer_A (void)
{
  CCR0 += Bitime;     // Add Offset to CCR0  
  if ( BitCnt == 0)     // If all bits TXed, disable interrupt
    CCTL0 &= ~ CCIE ;
    fad6:	b2 f0 ef ff 	and	#-17,	&0x0162	;#0xffef
    fada:	62 01 
    if (TXByte & 0x01)
      CCTL0 &= ~ OUTMOD2;                   // TX Mark
    TXByte = TXByte >> 1;
    BitCnt --;
  }
}
    fadc:	3d 41       	pop	r13		
    fade:	3e 41       	pop	r14		
    fae0:	3f 41       	pop	r15		
    fae2:	00 13       	reti			

0000fae4 <asciiCode>:
    fae4:	30 31 32 33 34 35 36 37 38 39 41 42 43 44 45 46     0123456789ABCDEF

0000faf4 <_unexpected_>:
    faf4:	00 13       	reti			

Disassembly of section .vectors:

0000ffe0 <__ivtbl_16>:
    ffe0:	cc f8 cc f8 cc f8 cc f8 cc f8 8e fa cc f8 cc f8     ................
    fff0:	cc f8 96 fa 7a fa cc f8 cc f8 cc f8 cc f8 00 f8     ....z...........
