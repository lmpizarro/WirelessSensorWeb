
main.elf:     file format elf32-msp430

SYMBOL TABLE:
0000f800 l    d  .text	00000000 .text
00000200 l    d  .data	00000000 .data
0000020c l    d  .bss	00000000 .bss
0000ffe0 l    d  .vectors	00000000 .vectors
00000000 l    d  .debug_aranges	00000000 .debug_aranges
00000000 l    d  .debug_pubnames	00000000 .debug_pubnames
00000000 l    d  .debug_info	00000000 .debug_info
00000000 l    d  .debug_abbrev	00000000 .debug_abbrev
00000000 l    d  .debug_line	00000000 .debug_line
00000000 l    d  .debug_frame	00000000 .debug_frame
00000000 l    d  .debug_str	00000000 .debug_str
00000000 l    d  .debug_loc	00000000 .debug_loc
00000000 l    d  .debug_pubtypes	00000000 .debug_pubtypes
00000000 l    d  .debug_ranges	00000000 .debug_ranges
00000000 l    df *ABS*	00000000 main.c
0000fc44 l     O .text	00000010 asciiCode
0000f93a l       .text	00000000 __br_unexpected_
00000000 l    df *ABS*	00000000 rand.c
00000208 l     O .data	00000004 next
0000007c g       *ABS*	00000000 __USISR
00000057 g       *ABS*	00000000 __BCSCTL1
00000174 g       *ABS*	00000000 __TACCR1
0000000c g       *ABS*	00000000 __data_size
0000f93a  w      .text	00000000 __isr_14
0000f968 g     F .text	00000008 ADC10_ISR
0000007a g       *ABS*	00000000 __USICKCTL
00000128 g       *ABS*	00000000 __FCTL1
00000024 g       *ABS*	00000000 __P1IES
0000f93a  w      .text	00000000 __isr_4
00000002 g       *ABS*	00000000 __IFG1
0000f9fe g     F .text	00000122 TransmitADCValue
0000012e g       *ABS*	00000000 __TAIV
00000000 g       .vectors	00000000 _efartext
0000002b g       *ABS*	00000000 __P2IFG
0000fb20 g     F .text	000000ca genRand03
0000fd8a g       *ABS*	00000000 _etext
0000f9b0 g     F .text	0000004e Timer_A
00000006 g       *ABS*	00000000 __bss_size
00000078 g       *ABS*	00000000 __USICTL
0000f934  w      .text	00000000 __stop_progExec__
0000002d g       *ABS*	00000000 __P2IE
0000f93a  w      .text	00000000 __isr_11
00000025 g       *ABS*	00000000 __P1IE
00000049 g       *ABS*	00000000 __ADC10DTC1
0000f968 g       .text	00000000 __isr_5
0000fd8a g       *ABS*	00000000 __data_load_start
0000f93a g       .text	00000000 __dtors_end
00000053 g       *ABS*	00000000 __BCSCTL3
000001bc g       *ABS*	00000000 __ADC10SA
0000007a g       *ABS*	00000000 __USICCTL
0000f93a  w      .text	00000000 __isr_2
0000f970 g     F .text	00000040 Transmit
00000160 g       *ABS*	00000000 __TACTL
0000012c g       *ABS*	00000000 __FCTL3
0000f93a  w      .text	00000000 __isr_10
0000002e g       *ABS*	00000000 __P2SEL
00000023 g       *ABS*	00000000 __P1IFG
0000004a g       *ABS*	00000000 __ADC10AE0
00000172 g       *ABS*	00000000 __TACCR0
00000056 g       *ABS*	00000000 __DCOCTL
0000fc3c g     O .text	00000001 deviceID
0000f93a  w      .text	00000000 __isr_7
0000ffe0 g     O .vectors	00000020 __ivtbl_16
0000fc54 g     F .text	00000094 rand_r
00000028 g       *ABS*	00000000 __P2IN
0000f93e g     F .text	0000001a ConfigureAdcTempSensor
000001b4 g       *ABS*	00000000 __ADC10MEM
0000fbea g     F .text	00000016 Timer_A1
0000f93a  w      .text	00000000 __isr_0
00000029 g       *ABS*	00000000 __P2OUT
0000012a g       *ABS*	00000000 __FCTL2
0000f824  w      .text	00000000 __do_clear_bss
00000021 g       *ABS*	00000000 __P1OUT
0000fc00 g     F .text	0000002a setVloClk
0000002c g       *ABS*	00000000 __P2IES
00000026 g       *ABS*	00000000 __P1SEL
0000020c g     O .bss	00000001 ADCDone
0000fce8 g     F .text	00000096 rand
00000079 g       *ABS*	00000000 __USICTL1
00000027 g       *ABS*	00000000 __P1REN
0000fd88  w      .text	00000000 _unexpected_
0000fbea g       .text	00000000 __isr_8
00000200 g     O .data	00000004 sampleTimeSec
0000f93a  w      .text	00000000 __isr_3
0000f800  w      .text	00000000 _reset_vector__
0000f93a g       .text	00000000 __ctors_start
0000f93a  w      .text	00000000 __isr_12
0000f80e  w      .text	00000000 __do_copy_data
00000204 g     O .data	00000004 dlyCC1
0000020c g       .bss	00000000 __bss_start
0000020d g     O .bss	00000001 BitCnt
0000f838 g     F .text	000000fc main
0000020e g     O .bss	00000002 TXByte
0000fd7e g     F .text	0000000a srand
0000f93a  w      .text	00000000 __isr_13
00000170 g       *ABS*	00000000 __TAR
00000162 g       *ABS*	00000000 __TACCTL0
00010000 g       .vectors	00000000 _vectors_end
0000002a g       *ABS*	00000000 __P2DIR
0000002f g       *ABS*	00000000 __P2REN
0000007d g       *ABS*	00000000 __USISRH
0000f958 g     F .text	00000010 adqAdcTempSensor
00000210 g     O .bss	00000002 ADCValue
000001b0 g       *ABS*	00000000 __ADC10CTL0
0000f9b0 g       .text	00000000 __isr_9
000010fe g       *ABS*	00000000 __CALDCO_1MHZ
0000f800  w      .text	00000000 __init_stack
0000f93a g       .text	00000000 __dtors_start
0000f93a  w      .text	00000000 __isr_6
0000f93a g       .text	00000000 __ctors_end
00000280 g       *ABS*	00000000 __stack
0000f93a  w      .text	00000000 __isr_1
0000020c g       .data	00000000 _edata
00000212 g       .bss	00000000 _end
0000007b g       *ABS*	00000000 __USICNT
00000048 g       *ABS*	00000000 __ADC10DTC0
000001b2 g       *ABS*	00000000 __ADC10CTL1
00000058 g       *ABS*	00000000 __BCSCTL2
0000f934  w      .text	00000000 _endless_loop__
00000022 g       *ABS*	00000000 __P1DIR
00000164 g       *ABS*	00000000 __TACCTL1
0000fc42 g     O .text	00000002 Bitime
000010ff g       *ABS*	00000000 __CALBC1_1MHZ
0000fc3e g     O .text	00000004 minTime
0000f804  w      .text	00000000 __low_level_init
0000fc2a g     F .text	00000012 setClockTrans
00000200 g       .data	00000000 __data_start
00000120 g       *ABS*	00000000 __WDTCTL
00000000 g       *ABS*	00000000 __IE1
00000078 g       *ABS*	00000000 __USICTL0
00000020 g       *ABS*	00000000 __P1IN
0000007c g       *ABS*	00000000 __USISRL



Disassembly of section .text:

0000f800 <__init_stack>:
    f800:	31 40 80 02 	mov	#640,	r1	;#0x0280

0000f804 <__low_level_init>:
    f804:	15 42 20 01 	mov	&0x0120,r5	
    f808:	75 f3       	and.b	#-1,	r5	;r3 As==11
    f80a:	35 d0 08 5a 	bis	#23048,	r5	;#0x5a08

0000f80e <__do_copy_data>:
    f80e:	3f 40 0c 00 	mov	#12,	r15	;#0x000c
    f812:	0f 93       	tst	r15		
    f814:	07 24       	jz	$+16     	;abs 0xf824
    f816:	82 45 20 01 	mov	r5,	&0x0120	
    f81a:	2f 83       	decd	r15		
    f81c:	9f 4f 8a fd 	mov	-630(r15),512(r15);0xfd8a(r15), 0x0200(r15)
    f820:	00 02 
    f822:	f9 23       	jnz	$-12     	;abs 0xf816

0000f824 <__do_clear_bss>:
    f824:	3f 40 06 00 	mov	#6,	r15	;#0x0006
    f828:	0f 93       	tst	r15		
    f82a:	06 24       	jz	$+14     	;abs 0xf838
    f82c:	82 45 20 01 	mov	r5,	&0x0120	
    f830:	1f 83       	dec	r15		
    f832:	cf 43 0c 02 	mov.b	#0,	524(r15);r3 As==00, 0x020c(r15)
    f836:	fa 23       	jnz	$-10     	;abs 0xf82c

0000f838 <main>:


void main (){
  long int tSampleMs, auxTimeMs;

  WDTCTL = WDTPW + WDTHOLD;                // Stop watchdog timer
    f838:	b2 40 80 5a 	mov	#23168,	&0x0120	;#0x5a80
    f83c:	20 01 
  P1SEL |= TXD + APC220_CTL;
    f83e:	f2 d0 03 00 	bis.b	#3,	&0x0026	;#0x0003
    f842:	26 00 
  P1DIR |= 0x40 + TXD + APC220_CTL;                           // Set P1.0  y P1.6 to output direction
    f844:	f2 d0 43 00 	bis.b	#67,	&0x0022	;#0x0043
    f848:	22 00 
  P1REN |= APC220_CTL;
    f84a:	d2 d3 27 00 	bis.b	#1,	&0x0027	;r3 As==01
  
  //P1OUT = 0x00;

    ConfigureAdcTempSensor();
    f84e:	b0 12 3e f9 	call	#0xf93e	

    __enable_interrupt();                     // Enable interrupts.
    f852:	32 d2       	eint			

    BCSCTL1 |= DIVA_0;                               // ACLK / 8
    BCSCTL2 |= SELM_3 + DIVM_3 + SELS + DIVS_3;               // MCLK = LFXT1/8
    f854:	f2 d0 fe ff 	bis.b	#-2,	&0x0058	;#0xfffe
    f858:	58 00 
    BCSCTL3 |= LFXT1S_2;                      // LFXT1 = VLO
    f85a:	f2 d0 20 00 	bis.b	#32,	&0x0053	;#0x0020
    f85e:	53 00 
    IFG1 &= ~OFIFG;                           // Clear OSCFault flag
    f860:	f2 f0 fd ff 	and.b	#-3,	&0x0002	;#0xfffd
    f864:	02 00 
    __bis_SR_register(SCG1 + SCG0);           // Stop DCO
    f866:	32 d0 c0 00 	bis	#192,	r2	;#0x00c0


    CCTL1 = CCIE;                            // interrupt enabled CC1
    f86a:	b2 40 10 00 	mov	#16,	&0x0164	;#0x0010
    f86e:	64 01 
    CCR1 = dlyCC1;
    f870:	92 42 04 02 	mov	&0x0204,&0x0174	
    f874:	74 01 
    TACTL = TASSEL_1 + MC_2;                 // ACLK, upmode
    f876:	b2 40 20 01 	mov	#288,	&0x0160	;#0x0120
    f87a:	60 01 
   
    srand(deviceID); 
    f87c:	3f 40 23 00 	mov	#35,	r15	;#0x0023
    f880:	b0 12 7e fd 	call	#0xfd7e	
  // 60000 ciclos 5 segundos
  // 12000 ciclos 1 segundo
  //
  // 12    ciclos 1 mS
  //
  sampleTimeSec =  10;
    f884:	b2 40 0a 00 	mov	#10,	&0x0200	;#0x000a
    f888:	00 02 
    f88a:	82 43 02 02 	mov	#0,	&0x0202	;r3 As==00
  tSampleMs = sampleTimeSec * 1000;

  auxTimeMs = genRand03(tSampleMs);
    f88e:	3e 40 10 27 	mov	#10000,	r14	;#0x2710
    f892:	0f 43       	clr	r15		
    f894:	b0 12 20 fb 	call	#0xfb20	
    f898:	0a 4e       	mov	r14,	r10	
    f89a:	0b 4f       	mov	r15,	r11	
  while(1){
    if (auxTimeMs > minTime) {
    f89c:	38 40 88 13 	mov	#5000,	r8	;#0x1388
    f8a0:	09 43       	clr	r9		
    f8a2:	0b 93       	tst	r11		
    f8a4:	02 20       	jnz	$+6      	;abs 0xf8aa
    f8a6:	08 9a       	cmp	r10,	r8	
    f8a8:	09 2c       	jc	$+20     	;abs 0xf8bc
         //P1OUT |= 0x01;                           // 0100|0001 = 0x41 pone en 1 P1.0 y P1.6
         //P1OUT &= ~0x01;                           // 0100|0001 = 0x41 pone en 1 P1.0 y P1.6
      auxTimeMs = auxTimeMs - minTime;
    f8aa:	3a 50 78 ec 	add	#-5000,	r10	;#0xec78
    f8ae:	3b 63       	addc	#-1,	r11	;r3 As==11
      _BIS_SR(LPM3_bits + GIE);                // Enter LPM3 w/ interrupt
    f8b0:	32 d0 d8 00 	bis	#216,	r2	;#0x00d8
  sampleTimeSec =  10;
  tSampleMs = sampleTimeSec * 1000;

  auxTimeMs = genRand03(tSampleMs);
  while(1){
    if (auxTimeMs > minTime) {
    f8b4:	0b 93       	tst	r11		
    f8b6:	f9 23       	jnz	$-12     	;abs 0xf8aa
    f8b8:	08 9a       	cmp	r10,	r8	
    f8ba:	f7 2b       	jnc	$-16     	;abs 0xf8aa
         //P1OUT |= 0x01;                           // 0100|0001 = 0x41 pone en 1 P1.0 y P1.6
         //P1OUT &= ~0x01;                           // 0100|0001 = 0x41 pone en 1 P1.0 y P1.6
      auxTimeMs = auxTimeMs - minTime;
      _BIS_SR(LPM3_bits + GIE);                // Enter LPM3 w/ interrupt
    }else {
      if (auxTimeMs == 0){
    f8bc:	0a 93       	tst	r10		
    f8be:	09 24       	jz	$+20     	;abs 0xf8d2
         CCTL0 &= ~CCIE;                            // interrupt disabled CC0
         CCR1 = dlyCC1;
         setVloClk();
 
     } else {
       CCR1 = auxTimeMs * 12;
    f8c0:	0f 4a       	mov	r10,	r15	
    f8c2:	0f 5f       	rla	r15		
    f8c4:	0f 5a       	add	r10,	r15	
    f8c6:	0f 5f       	rla	r15		
    f8c8:	0f 5f       	rla	r15		
    f8ca:	82 4f 74 01 	mov	r15,	&0x0174	
       auxTimeMs = 0;
       _BIS_SR(LPM3_bits + GIE);                // Enter LPM3 w/ interrupt
    f8ce:	32 d0 d8 00 	bis	#216,	r2	;#0x00d8
         //P1OUT &= ~0x01;                           // 0100|0001 = 0x41 pone en 1 P1.0 y P1.6
      auxTimeMs = auxTimeMs - minTime;
      _BIS_SR(LPM3_bits + GIE);                // Enter LPM3 w/ interrupt
    }else {
      if (auxTimeMs == 0){
         CCTL1 &= ~CCIE;                            // interrupt disabled CC1
    f8d2:	b2 f0 ef ff 	and	#-17,	&0x0164	;#0xffef
    f8d6:	64 01 

}

void setClockTrans(){

    BCSCTL1 = CALBC1_1MHZ;           // Set range
    f8d8:	d2 42 ff 10 	mov.b	&0x10ff,&0x0057	
    f8dc:	57 00 
    DCOCTL = CALDCO_1MHZ;            // SMCLK = DCO = 1MHz
    f8de:	d2 42 fe 10 	mov.b	&0x10fe,&0x0056	
    f8e2:	56 00 
    //BCSCTL2 |= SELM_1 + DIVM_0;               // MCLK = LFXT1/8
    BCSCTL2 = 0x00;               // MCLK = LFXT1/8
    f8e4:	c2 43 58 00 	mov.b	#0,	&0x0058	;r3 As==00
    }else {
      if (auxTimeMs == 0){
         CCTL1 &= ~CCIE;                            // interrupt disabled CC1
         setClockTrans();

         auxTimeMs = genRand03(tSampleMs);
    f8e8:	3e 40 10 27 	mov	#10000,	r14	;#0x2710
    f8ec:	0f 43       	clr	r15		
    f8ee:	b0 12 20 fb 	call	#0xfb20	
    f8f2:	0a 4e       	mov	r14,	r10	
    f8f4:	0b 4f       	mov	r15,	r11	

         ADCValue = adqAdcTempSensor();
    f8f6:	b0 12 58 f9 	call	#0xf958	
    f8fa:	82 4f 10 02 	mov	r15,	&0x0210	
         P1OUT = 0x41;                           // 0100|0001 = 0x41 pone en 1 P1.0 y P1.6
    f8fe:	f2 40 41 00 	mov.b	#65,	&0x0021	;#0x0041
    f902:	21 00 
         int i;
         for (i = 0; i < 100; i++) __delay_cycles(500);
    f904:	0f 43       	clr	r15		
    f906:	3d 40 a6 00 	mov	#166,	r13	;#0x00a6
    f90a:	1d 83       	dec	r13		
    f90c:	fe 23       	jnz	$-2      	;abs 0xf90a
    f90e:	1f 53       	inc	r15		
    f910:	3f 90 64 00 	cmp	#100,	r15	;#0x0064
    f914:	f8 23       	jnz	$-14     	;abs 0xf906

         TransmitADCValue (deviceID);
    f916:	3f 50 bf ff 	add	#-65,	r15	;#0xffbf
    f91a:	b0 12 fe f9 	call	#0xf9fe	
         P1OUT = 0x00;                          // 1011|1110 = 0xFE pone en 0 P1.0 
    f91e:	c2 43 21 00 	mov.b	#0,	&0x0021	;r3 As==00

         CCTL0 &= ~CCIE;                            // interrupt disabled CC0
    f922:	b2 f0 ef ff 	and	#-17,	&0x0162	;#0xffef
    f926:	62 01 
         CCR1 = dlyCC1;
    f928:	92 42 04 02 	mov	&0x0204,&0x0174	
    f92c:	74 01 
         setVloClk();
    f92e:	b0 12 00 fc 	call	#0xfc00	
    f932:	b7 3f       	jmp	$-144    	;abs 0xf8a2

0000f934 <__stop_progExec__>:
    f934:	32 d0 f0 00 	bis	#240,	r2	;#0x00f0
    f938:	fd 3f       	jmp	$-4      	;abs 0xf934

0000f93a <__ctors_end>:
    f93a:	30 40 88 fd 	br	#0xfd88	

0000f93e <ConfigureAdcTempSensor>:
/* Configure ADC Temp Sensor Channel */
void ConfigureAdcTempSensor(void)
{
//  unsigned char i;
  ADC10CTL1 = INCH_10 + ADC10DIV_3;         // Temp Sensor ADC10CLK/4
    f93e:	b2 40 60 a0 	mov	#-24480,&0x01b2	;#0xa060
    f942:	b2 01 
  ADC10CTL0 = SREF_1 + ADC10SHT_3 + REFON + ADC10ON + ADC10IE;
    f944:	b2 40 38 38 	mov	#14392,	&0x01b0	;#0x3838
    f948:	b0 01 
  __delay_cycles(1000);                     // Wait for ADC Ref to settle
    f94a:	03 43       	nop			
    f94c:	03 43       	nop			
    f94e:	3f 40 4c 01 	mov	#332,	r15	;#0x014c
    f952:	1f 83       	dec	r15		
    f954:	fe 23       	jnz	$-2      	;abs 0xf952
//  __bis_SR_register(CPUOFF + GIE);          // LPM0 with interrupts enabled
//  tempCalibrated = ADC10MEM;
//  for (i=0; i < 8; i++)
//    tempMeasured[i] = tempCalibrated;
//  tempAverage = tempCalibrated;
}
    f956:	30 41       	ret			

0000f958 <adqAdcTempSensor>:

int  adqAdcTempSensor(void)
{
   ADC10CTL0 |= ENC + ADC10SC;             // Sampling and conversion start
    f958:	b2 d0 03 00 	bis	#3,	&0x01b0	;#0x0003
    f95c:	b0 01 
    __bis_SR_register(CPUOFF + GIE);        // LPM0 with interrupts enabled
    f95e:	32 d0 18 00 	bis	#24,	r2	;#0x0018
   return (ADC10MEM);
}
    f962:	1f 42 b4 01 	mov	&0x01b4,r15	
    f966:	30 41       	ret			

0000f968 <ADC10_ISR>:

// ADC10 interrupt service routine
interrupt (ADC10_VECTOR) ADC10_ISR(void)
{
  __bic_SR_register_on_exit(CPUOFF);        // Return to active mode
    f968:	b1 c0 10 00 	bic	#16,	0(r1)	;#0x0010, 0x0000(r1)
    f96c:	00 00 
}
    f96e:	00 13       	reti			

0000f970 <Transmit>:


// Function Transmits Character from TXByte
void Transmit()
{
  CCTL0 = OUT;                               // TXD Idle as Mark
    f970:	a2 42 62 01 	mov	#4,	&0x0162	;r2 As==10
  TACTL = TASSEL_2 + MC_2;               // SMCLK, continuous mode
    f974:	b2 40 20 02 	mov	#544,	&0x0160	;#0x0220
    f978:	60 01 

  BitCnt = 0xA;                       // Load Bit counter, 8 bits + ST/SP
    f97a:	f2 40 0a 00 	mov.b	#10,	&0x020d	;#0x000a
    f97e:	0d 02 
  CCR0 = TAR;
    f980:	92 42 70 01 	mov	&0x0170,&0x0172	
    f984:	72 01 

  CCR0 += Bitime;                  // Set time till first bit
    f986:	b2 50 68 00 	add	#104,	&0x0172	;#0x0068
    f98a:	72 01 
  TXByte |= 0x100;                 // Add stop bit to TXByte (which is logical 1)
  TXByte = TXByte << 1;            // Add start bit (which is logical 0)
    f98c:	1f 42 0e 02 	mov	&0x020e,r15	
    f990:	3f d0 00 01 	bis	#256,	r15	;#0x0100
    f994:	0f 5f       	rla	r15		
    f996:	82 4f 0e 02 	mov	r15,	&0x020e	


  CCTL0 =  CCIS0 + OUTMOD0 + CCIE; // Set signal, intial value, enable interrupts
    f99a:	b2 40 30 10 	mov	#4144,	&0x0162	;#0x1030
    f99e:	62 01 
  while ( CCTL0 & CCIE );          // Wait for TX completion
    f9a0:	b2 b0 10 00 	bit	#16,	&0x0162	;#0x0010
    f9a4:	62 01 
    f9a6:	fc 23       	jnz	$-6      	;abs 0xf9a0
  TACTL = TASSEL_2;             // SMCLK, timer off (for power consumption)
    f9a8:	b2 40 00 02 	mov	#512,	&0x0160	;#0x0200
    f9ac:	60 01 
  
}
    f9ae:	30 41       	ret			

0000f9b0 <Timer_A>:

// Timer A0 interrupt service routine
interrupt (TIMERA0_VECTOR) Timer_A (void)
{ 
    f9b0:	0f 12       	push	r15		
    f9b2:	0e 12       	push	r14		
    f9b4:	0d 12       	push	r13		

  CCR0 += Bitime;     // Add Offset to CCR0
    f9b6:	b2 50 68 00 	add	#104,	&0x0172	;#0x0068
    f9ba:	72 01 
  if ( BitCnt == 0)     // If all bits TXed, disable interrupt
    f9bc:	5f 42 0d 02 	mov.b	&0x020d,r15	
    f9c0:	4f 93       	tst.b	r15		
    f9c2:	16 24       	jz	$+46     	;abs 0xf9f0
    CCTL0 &= ~ CCIE ;
  else
  {
    CCTL0 |=  OUTMOD2;                    // TX Space
    f9c4:	b2 d0 80 00 	bis	#128,	&0x0162	;#0x0080
    f9c8:	62 01 
    if (TXByte & 0x01)
    f9ca:	1e 42 0e 02 	mov	&0x020e,r14	
    f9ce:	1e b3       	bit	#1,	r14	;r3 As==01
    f9d0:	0b 20       	jnz	$+24     	;abs 0xf9e8
      CCTL0 &= ~ OUTMOD2;                   // TX Mark
    TXByte = TXByte >> 1;
    f9d2:	12 c3       	clrc			
    f9d4:	0e 10       	rrc	r14		
    f9d6:	82 4e 0e 02 	mov	r14,	&0x020e	
    BitCnt --;
    f9da:	7f 53       	add.b	#-1,	r15	;r3 As==11
    f9dc:	c2 4f 0d 02 	mov.b	r15,	&0x020d	
  }
}
    f9e0:	3d 41       	pop	r13		
    f9e2:	3e 41       	pop	r14		
    f9e4:	3f 41       	pop	r15		
    f9e6:	00 13       	reti			
    CCTL0 &= ~ CCIE ;
  else
  {
    CCTL0 |=  OUTMOD2;                    // TX Space
    if (TXByte & 0x01)
      CCTL0 &= ~ OUTMOD2;                   // TX Mark
    f9e8:	b2 f0 7f ff 	and	#-129,	&0x0162	;#0xff7f
    f9ec:	62 01 
    f9ee:	f1 3f       	jmp	$-28     	;abs 0xf9d2
interrupt (TIMERA0_VECTOR) Timer_A (void)
{ 

  CCR0 += Bitime;     // Add Offset to CCR0
  if ( BitCnt == 0)     // If all bits TXed, disable interrupt
    CCTL0 &= ~ CCIE ;
    f9f0:	b2 f0 ef ff 	and	#-17,	&0x0162	;#0xffef
    f9f4:	62 01 
    if (TXByte & 0x01)
      CCTL0 &= ~ OUTMOD2;                   // TX Mark
    TXByte = TXByte >> 1;
    BitCnt --;
  }
}
    f9f6:	3d 41       	pop	r13		
    f9f8:	3e 41       	pop	r14		
    f9fa:	3f 41       	pop	r15		
    f9fc:	00 13       	reti			

0000f9fe <TransmitADCValue>:
bool ADCDone;                   // ADC Done flag

#define codFunc       4


void TransmitADCValue (unsigned int SensorId){
    f9fe:	0b 12       	push	r11		
    fa00:	0a 12       	push	r10		
    fa02:	09 12       	push	r9		
    fa04:	08 12       	push	r8		
    fa06:	07 12       	push	r7		
    fa08:	0b 4f       	mov	r15,	r11	
  unsigned int cksum = 0;

  /*************************************************************/  
  // Transmitir Comienzo  de Mensaje ':'
  /*************************************************************/  
   TXByte = ':';
    fa0a:	b2 40 3a 00 	mov	#58,	&0x020e	;#0x003a
    fa0e:	0e 02 
   cksum = cksum + TXByte;
   Transmit();
    fa10:	b0 12 70 f9 	call	#0xf970	

  /*************************************************************/  
  //  Transmitir el SensorId
  /*************************************************************/  

   TXByte = (SensorId >> 4) & 0x000F;
    fa14:	0e 4b       	mov	r11,	r14	
    fa16:	12 c3       	clrc			
    fa18:	0e 10       	rrc	r14		
    fa1a:	0e 11       	rra	r14		
    fa1c:	0e 11       	rra	r14		
    fa1e:	0e 11       	rra	r14		
    fa20:	3e f0 0f 00 	and	#15,	r14	;#0x000f
   TXByte  = asciiCode[TXByte];
    fa24:	5a 4e 44 fc 	mov.b	-956(r14),r10	;0xfc44(r14)
    fa28:	8a 11       	sxt	r10		
    fa2a:	82 4a 0e 02 	mov	r10,	&0x020e	
   cksum = cksum + TXByte;
   Transmit();                                           // Send
    fa2e:	b0 12 70 f9 	call	#0xf970	


  TXByte = SensorId & 0x000F;
    fa32:	3b f0 0f 00 	and	#15,	r11	;#0x000f
  TXByte  = asciiCode[TXByte];
    fa36:	59 4b 44 fc 	mov.b	-956(r11),r9	;0xfc44(r11)
    fa3a:	89 11       	sxt	r9		
    fa3c:	82 49 0e 02 	mov	r9,	&0x020e	
  cksum = cksum + TXByte;
  Transmit();                                           // Send
    fa40:	b0 12 70 f9 	call	#0xf970	

  /*************************************************************/  
  // Transmitir el codFunc 
  /*************************************************************/  
  TXByte = (codFunc >> 4) & 0x000F;
  TXByte  = asciiCode[TXByte];
    fa44:	b2 40 30 00 	mov	#48,	&0x020e	;#0x0030
    fa48:	0e 02 
  cksum = cksum + TXByte;
  Transmit();                                           // Send
    fa4a:	b0 12 70 f9 	call	#0xf970	


  TXByte = codFunc & 0x000F;
  TXByte  = asciiCode[TXByte];
    fa4e:	b2 40 34 00 	mov	#52,	&0x020e	;#0x0034
    fa52:	0e 02 
  cksum = cksum + TXByte;
  Transmit();                                           // Send
    fa54:	b0 12 70 f9 	call	#0xf970	


  /*************************************************************/  
  // Transmitir el valor del ADC
  /*************************************************************/
  TXByte = (ADCValue>>12) & 0x000F;
    fa58:	1f 42 10 02 	mov	&0x0210,r15	
    fa5c:	8f 10       	swpb	r15		
    fa5e:	3f f0 ff 00 	and	#255,	r15	;#0x00ff
    fa62:	12 c3       	clrc			
    fa64:	0f 10       	rrc	r15		
    fa66:	0f 11       	rra	r15		
    fa68:	0f 11       	rra	r15		
    fa6a:	0f 11       	rra	r15		
  TXByte  = asciiCode[TXByte];
    fa6c:	5b 4f 44 fc 	mov.b	-956(r15),r11	;0xfc44(r15)
    fa70:	8b 11       	sxt	r11		
    fa72:	82 4b 0e 02 	mov	r11,	&0x020e	
  cksum = cksum + TXByte;
  Transmit();                                           // Send
    fa76:	b0 12 70 f9 	call	#0xf970	

  TXByte = (ADCValue>>8) & 0x000F;
    fa7a:	1f 42 10 02 	mov	&0x0210,r15	
    fa7e:	8f 10       	swpb	r15		
    fa80:	3f f0 0f 00 	and	#15,	r15	;#0x000f
  TXByte  = asciiCode[TXByte];
    fa84:	57 4f 44 fc 	mov.b	-956(r15),r7	;0xfc44(r15)
    fa88:	87 11       	sxt	r7		
    fa8a:	82 47 0e 02 	mov	r7,	&0x020e	
  cksum = cksum + TXByte;
  Transmit();                                           // Send
    fa8e:	b0 12 70 f9 	call	#0xf970	

  TXByte = (ADCValue >> 4) & 0x000F;
    fa92:	1f 42 10 02 	mov	&0x0210,r15	
    fa96:	12 c3       	clrc			
    fa98:	0f 10       	rrc	r15		
    fa9a:	0f 11       	rra	r15		
    fa9c:	0f 11       	rra	r15		
    fa9e:	0f 11       	rra	r15		
    faa0:	3f f0 0f 00 	and	#15,	r15	;#0x000f
  TXByte  = asciiCode[TXByte];
    faa4:	58 4f 44 fc 	mov.b	-956(r15),r8	;0xfc44(r15)
    faa8:	88 11       	sxt	r8		
    faaa:	82 48 0e 02 	mov	r8,	&0x020e	
  cksum = cksum + TXByte;
  Transmit();                                           // Send
    faae:	b0 12 70 f9 	call	#0xf970	

  TXByte = ADCValue & 0x000F;
    fab2:	1f 42 10 02 	mov	&0x0210,r15	
    fab6:	3f f0 0f 00 	and	#15,	r15	;#0x000f
  TXByte  = asciiCode[TXByte];
    faba:	5f 4f 44 fc 	mov.b	-956(r15),r15	;0xfc44(r15)
    fabe:	8f 11       	sxt	r15		
    fac0:	82 4f 0e 02 	mov	r15,	&0x020e	
  /*************************************************************/  
  // Transmitir el codFunc 
  /*************************************************************/  
  TXByte = (codFunc >> 4) & 0x000F;
  TXByte  = asciiCode[TXByte];
  cksum = cksum + TXByte;
    fac4:	0b 5f       	add	r15,	r11	
  Transmit();                                           // Send


  TXByte = codFunc & 0x000F;
  TXByte  = asciiCode[TXByte];
  cksum = cksum + TXByte;
    fac6:	3b 50 9e 00 	add	#158,	r11	;#0x009e
  /*************************************************************/  
  // Transmitir el valor del ADC
  /*************************************************************/
  TXByte = (ADCValue>>12) & 0x000F;
  TXByte  = asciiCode[TXByte];
  cksum = cksum + TXByte;
    faca:	0b 57       	add	r7,	r11	
  Transmit();                                           // Send

  TXByte = (ADCValue>>8) & 0x000F;
  TXByte  = asciiCode[TXByte];
  cksum = cksum + TXByte;
    facc:	0b 58       	add	r8,	r11	
  Transmit();                                           // Send

  TXByte = (ADCValue >> 4) & 0x000F;
  TXByte  = asciiCode[TXByte];
  cksum = cksum + TXByte;
    face:	0b 59       	add	r9,	r11	
  Transmit();                                           // Send

  TXByte = ADCValue & 0x000F;
  TXByte  = asciiCode[TXByte];
  cksum = cksum + TXByte;
    fad0:	0b 5a       	add	r10,	r11	
  Transmit();                                           // Send
    fad2:	b0 12 70 f9 	call	#0xf970	

  /*************************************************************/  
  // Transmitir el cksum
  /*************************************************************/  

  TXByte = (cksum >> 4) & 0x000F;
    fad6:	0f 4b       	mov	r11,	r15	
    fad8:	12 c3       	clrc			
    fada:	0f 10       	rrc	r15		
    fadc:	0f 11       	rra	r15		
    fade:	0f 11       	rra	r15		
    fae0:	0f 11       	rra	r15		
    fae2:	3f f0 0f 00 	and	#15,	r15	;#0x000f
  TXByte  = asciiCode[TXByte];
    fae6:	3a 40 0e 02 	mov	#526,	r10	;#0x020e
    faea:	da 4f 44 fc 	mov.b	-956(r15),0(r10)	;0xfc44(r15), 0x0000(r10)
    faee:	00 00 
    faf0:	92 11 0e 02 	sxt	&0x020e	
  Transmit();                                           // Send
    faf4:	b0 12 70 f9 	call	#0xf970	

  TXByte = cksum & 0x000F;
    faf8:	3b f0 0f 00 	and	#15,	r11	;#0x000f
  TXByte  = asciiCode[TXByte];
    fafc:	da 4b 44 fc 	mov.b	-956(r11),0(r10)	;0xfc44(r11), 0x0000(r10)
    fb00:	00 00 
    fb02:	92 11 0e 02 	sxt	&0x020e	
  Transmit();                                           // Send
    fb06:	b0 12 70 f9 	call	#0xf970	

  /*************************************************************/  
   // Transmitir Fin de Mensaje '!'
  /*************************************************************/  
   TXByte = '!';
    fb0a:	b2 40 21 00 	mov	#33,	&0x020e	;#0x0021
    fb0e:	0e 02 
   Transmit();
    fb10:	b0 12 70 f9 	call	#0xf970	
}
    fb14:	37 41       	pop	r7		
    fb16:	38 41       	pop	r8		
    fb18:	39 41       	pop	r9		
    fb1a:	3a 41       	pop	r10		
    fb1c:	3b 41       	pop	r11		
    fb1e:	30 41       	ret			

0000fb20 <genRand03>:
#include  <limits.h>
#include  "defs.h"

#define genRand02()  (rand ()%tSampleMs + (tSampleMs));
//#define genRand03()  ((rand ()+INT_MAX)%tSampleMs) + tSampleMs/2;
long int  genRand03(long int tSampleMs)  {
    fb20:	0b 12       	push	r11		
    fb22:	0a 12       	push	r10		
    fb24:	09 12       	push	r9		
    fb26:	0a 4e       	mov	r14,	r10	
    fb28:	0b 4f       	mov	r15,	r11	
  //return(  (rand ()+INT_MAX)%tSampleMs + tSampleMs/2);
  int c;
  switch (sampleTimeSec){
    fb2a:	1f 42 00 02 	mov	&0x0200,r15	
    fb2e:	1e 42 02 02 	mov	&0x0202,r14	
    fb32:	3f 90 14 00 	cmp	#20,	r15	;#0x0014
    fb36:	3c 24       	jz	$+122    	;abs 0xfbb0
    fb38:	0e 93       	tst	r14		
    fb3a:	21 20       	jnz	$+68     	;abs 0xfb7e
    fb3c:	3f 90 15 00 	cmp	#21,	r15	;#0x0015
    fb40:	1e 2c       	jc	$+62     	;abs 0xfb7e
    fb42:	3f 90 05 00 	cmp	#5,	r15	;#0x0005
    fb46:	3f 24       	jz	$+128    	;abs 0xfbc6
    fb48:	3f 90 0a 00 	cmp	#10,	r15	;#0x000a
    fb4c:	39 24       	jz	$+116    	;abs 0xfbc0
    break; 
    case 60:
     c = 0;
    break; 
    default :
     c = 0;
    fb4e:	09 43       	clr	r9		
    break; 
  };

  int x = rand ();
    fb50:	b0 12 e8 fc 	call	#0xfce8	
  int s = (x > 0) ? 1 : ((x < 0) ? -1 : 0);
    fb54:	1f 93       	cmp	#1,	r15	;r3 As==01
    fb56:	20 38       	jl	$+66     	;abs 0xfb98
    fb58:	09 93       	tst	r9		
    fb5a:	03 24       	jz	$+8      	;abs 0xfb62
    fb5c:	0f 11       	rra	r15		
    fb5e:	19 83       	dec	r9		
    fb60:	fd 23       	jnz	$-4      	;abs 0xfb5c
    fb62:	0d 4f       	mov	r15,	r13	
    fb64:	0e 4f       	mov	r15,	r14	
    fb66:	8e 10       	swpb	r14		
    fb68:	8e 11       	sxt	r14		
    fb6a:	8e 10       	swpb	r14		
    fb6c:	8e 11       	sxt	r14		

  return(((long int )(s)*(x>>c) + tSampleMs));
};
    fb6e:	0f 4e       	mov	r14,	r15	
    fb70:	0e 4d       	mov	r13,	r14	
    fb72:	0e 5a       	add	r10,	r14	
    fb74:	0f 6b       	addc	r11,	r15	
    fb76:	39 41       	pop	r9		
    fb78:	3a 41       	pop	r10		
    fb7a:	3b 41       	pop	r11		
    fb7c:	30 41       	ret			
#define genRand02()  (rand ()%tSampleMs + (tSampleMs));
//#define genRand03()  ((rand ()+INT_MAX)%tSampleMs) + tSampleMs/2;
long int  genRand03(long int tSampleMs)  {
  //return(  (rand ()+INT_MAX)%tSampleMs + tSampleMs/2);
  int c;
  switch (sampleTimeSec){
    fb7e:	3f 90 1e 00 	cmp	#30,	r15	;#0x001e
    fb82:	1a 24       	jz	$+54     	;abs 0xfbb8
    fb84:	3f 90 3c 00 	cmp	#60,	r15	;#0x003c
    fb88:	e2 23       	jnz	$-58     	;abs 0xfb4e
    fb8a:	0e 93       	tst	r14		
    fb8c:	e0 23       	jnz	$-62     	;abs 0xfb4e
    break; 
    case 30:
     c = 1;
    break; 
    case 60:
     c = 0;
    fb8e:	09 4e       	mov	r14,	r9	
    default :
     c = 0;
    break; 
  };

  int x = rand ();
    fb90:	b0 12 e8 fc 	call	#0xfce8	
  int s = (x > 0) ? 1 : ((x < 0) ? -1 : 0);
    fb94:	1f 93       	cmp	#1,	r15	;r3 As==01
    fb96:	e0 37       	jge	$-62     	;abs 0xfb58
    fb98:	0f 93       	tst	r15		
    fb9a:	17 20       	jnz	$+48     	;abs 0xfbca
    fb9c:	0d 43       	clr	r13		
    fb9e:	0e 43       	clr	r14		

  return(((long int )(s)*(x>>c) + tSampleMs));
};
    fba0:	0f 4e       	mov	r14,	r15	
    fba2:	0e 4d       	mov	r13,	r14	
    fba4:	0e 5a       	add	r10,	r14	
    fba6:	0f 6b       	addc	r11,	r15	
    fba8:	39 41       	pop	r9		
    fbaa:	3a 41       	pop	r10		
    fbac:	3b 41       	pop	r11		
    fbae:	30 41       	ret			
#define genRand02()  (rand ()%tSampleMs + (tSampleMs));
//#define genRand03()  ((rand ()+INT_MAX)%tSampleMs) + tSampleMs/2;
long int  genRand03(long int tSampleMs)  {
  //return(  (rand ()+INT_MAX)%tSampleMs + tSampleMs/2);
  int c;
  switch (sampleTimeSec){
    fbb0:	0e 93       	tst	r14		
    fbb2:	c2 23       	jnz	$-122    	;abs 0xfb38
    break; 
    case 10:
     c = 3;
    break; 
    case 20:
     c = 2;
    fbb4:	29 43       	mov	#2,	r9	;r3 As==10
    fbb6:	cc 3f       	jmp	$-102    	;abs 0xfb50
#define genRand02()  (rand ()%tSampleMs + (tSampleMs));
//#define genRand03()  ((rand ()+INT_MAX)%tSampleMs) + tSampleMs/2;
long int  genRand03(long int tSampleMs)  {
  //return(  (rand ()+INT_MAX)%tSampleMs + tSampleMs/2);
  int c;
  switch (sampleTimeSec){
    fbb8:	0e 93       	tst	r14		
    fbba:	c9 23       	jnz	$-108    	;abs 0xfb4e
    break; 
    case 20:
     c = 2;
    break; 
    case 30:
     c = 1;
    fbbc:	19 43       	mov	#1,	r9	;r3 As==01
    fbbe:	c8 3f       	jmp	$-110    	;abs 0xfb50
  switch (sampleTimeSec){
    case 5:
     c = 4;
    break; 
    case 10:
     c = 3;
    fbc0:	39 40 03 00 	mov	#3,	r9	;#0x0003
    fbc4:	c5 3f       	jmp	$-116    	;abs 0xfb50
long int  genRand03(long int tSampleMs)  {
  //return(  (rand ()+INT_MAX)%tSampleMs + tSampleMs/2);
  int c;
  switch (sampleTimeSec){
    case 5:
     c = 4;
    fbc6:	29 42       	mov	#4,	r9	;r2 As==10
    fbc8:	c3 3f       	jmp	$-120    	;abs 0xfb50
     c = 0;
    break; 
  };

  int x = rand ();
  int s = (x > 0) ? 1 : ((x < 0) ? -1 : 0);
    fbca:	09 93       	tst	r9		
    fbcc:	03 24       	jz	$+8      	;abs 0xfbd4
    fbce:	0f 11       	rra	r15		
    fbd0:	19 83       	dec	r9		
    fbd2:	fd 23       	jnz	$-4      	;abs 0xfbce
    fbd4:	0d 4f       	mov	r15,	r13	
    fbd6:	0e 4f       	mov	r15,	r14	
    fbd8:	8e 10       	swpb	r14		
    fbda:	8e 11       	sxt	r14		
    fbdc:	8e 10       	swpb	r14		
    fbde:	8e 11       	sxt	r14		
    fbe0:	3d e3       	inv	r13		
    fbe2:	3e e3       	inv	r14		
    fbe4:	1d 53       	inc	r13		
    fbe6:	0e 63       	adc	r14		
    fbe8:	c2 3f       	jmp	$-122    	;abs 0xfb6e

0000fbea <Timer_A1>:

// Timer A1 interrupt service routine
interrupt (TIMERA1_VECTOR) Timer_A1 (void)
{
//   TACCTL1 &= ~CCIFG;                         /* Capture/compare interrupt flag */
   switch( TAIV )
    fbea:	a2 93 2e 01 	cmp	#2,	&0x012e	;r3 As==10
    fbee:	01 24       	jz	$+4      	;abs 0xfbf2
       _BIC_SR_IRQ(LPM3_bits);                   // Clear LPM3 bits from 0(SR)
       break;
       case  4: 
       break;
   }
}
    fbf0:	00 13       	reti			
   switch( TAIV )
     {
       case 10: 
       break;
       case 2:
       CCR1 += dlyCC1;
    fbf2:	92 52 04 02 	add	&0x0204,&0x0174	
    fbf6:	74 01 
       // TAR = 0;
       _BIC_SR_IRQ(LPM3_bits);                   // Clear LPM3 bits from 0(SR)
    fbf8:	b1 c0 d0 00 	bic	#208,	0(r1)	;#0x00d0, 0x0000(r1)
    fbfc:	00 00 
       break;
       case  4: 
       break;
   }
}
    fbfe:	00 13       	reti			

0000fc00 <setVloClk>:


void setVloClk (void){

    BCSCTL1 |= DIVA_0;                               // ACLK / 8
    BCSCTL2 |= SELM_3 + DIVM_3 + SELS + DIVS_3;               // MCLK = LFXT1/8
    fc00:	f2 d0 fe ff 	bis.b	#-2,	&0x0058	;#0xfffe
    fc04:	58 00 
    BCSCTL3 |= LFXT1S_2;                      // LFXT1 = VLO
    fc06:	f2 d0 20 00 	bis.b	#32,	&0x0053	;#0x0020
    fc0a:	53 00 
    IFG1 &= ~OFIFG;                           // Clear OSCFault flag
    fc0c:	f2 f0 fd ff 	and.b	#-3,	&0x0002	;#0xfffd
    fc10:	02 00 
    __bis_SR_register(SCG1 + SCG0);           // Stop DCO
    fc12:	32 d0 c0 00 	bis	#192,	r2	;#0x00c0


    CCTL1 = CCIE;                            // interrupt enabled CC1
    fc16:	b2 40 10 00 	mov	#16,	&0x0164	;#0x0010
    fc1a:	64 01 
    CCR1 = dlyCC1;
    fc1c:	92 42 04 02 	mov	&0x0204,&0x0174	
    fc20:	74 01 
    TACTL = TASSEL_1 + MC_2;                 // ACLK, upmode
    fc22:	b2 40 20 01 	mov	#288,	&0x0160	;#0x0120
    fc26:	60 01 

}
    fc28:	30 41       	ret			

0000fc2a <setClockTrans>:

void setClockTrans(){

    BCSCTL1 = CALBC1_1MHZ;           // Set range
    fc2a:	d2 42 ff 10 	mov.b	&0x10ff,&0x0057	
    fc2e:	57 00 
    DCOCTL = CALDCO_1MHZ;            // SMCLK = DCO = 1MHz
    fc30:	d2 42 fe 10 	mov.b	&0x10fe,&0x0056	
    fc34:	56 00 
    //BCSCTL2 |= SELM_1 + DIVM_0;               // MCLK = LFXT1/8
    BCSCTL2 = 0x00;               // MCLK = LFXT1/8
    fc36:	c2 43 58 00 	mov.b	#0,	&0x0058	;r3 As==00

    //CCTL0 = CCIE;                            // interrupt enabled CC1
    //CCR0 = dlyCC0;
    //TACTL = TASSEL_2 + MC_2;                 // SMCLK, upmode

}
    fc3a:	30 41       	ret			

0000fc3c <deviceID>:
    fc3c:	23 00                                               #.

0000fc3e <minTime>:
    fc3e:	88 13 00 00                                         ....

0000fc42 <Bitime>:
    fc42:	68 00                                               h.

0000fc44 <asciiCode>:
    fc44:	30 31 32 33 34 35 36 37 38 39 41 42 43 44 45 46     0123456789ABCDEF

0000fc54 <rand_r>:
    fc54:	0b 12       	push	r11		
    fc56:	0a 12       	push	r10		
    fc58:	09 12       	push	r9		
    fc5a:	09 4f       	mov	r15,	r9	
    fc5c:	2a 4f       	mov	@r15,	r10	
    fc5e:	0b 43       	clr	r11		
    fc60:	0e 4a       	mov	r10,	r14	
    fc62:	0f 4b       	mov	r11,	r15	
    fc64:	4f ee       	xor.b	r14,	r15	
    fc66:	0f ee       	xor	r14,	r15	
    fc68:	8f 10       	swpb	r15		
    fc6a:	7e f3       	and.b	#-1,	r14	;r3 As==11
    fc6c:	8e 10       	swpb	r14		
    fc6e:	0e 5e       	rla	r14		
    fc70:	0f 6f       	rlc	r15		
    fc72:	0e 8a       	sub	r10,	r14	
    fc74:	0f 7b       	subc	r11,	r15	
    fc76:	0e 5e       	rla	r14		
    fc78:	0f 6f       	rlc	r15		
    fc7a:	0e 5e       	rla	r14		
    fc7c:	0f 6f       	rlc	r15		
    fc7e:	0e 5a       	add	r10,	r14	
    fc80:	0f 6b       	addc	r11,	r15	
    fc82:	0c 4e       	mov	r14,	r12	
    fc84:	0d 4f       	mov	r15,	r13	
    fc86:	4d ec       	xor.b	r12,	r13	
    fc88:	0d ec       	xor	r12,	r13	
    fc8a:	8d 10       	swpb	r13		
    fc8c:	7c f3       	and.b	#-1,	r12	;r3 As==11
    fc8e:	8c 10       	swpb	r12		
    fc90:	0c 5c       	rla	r12		
    fc92:	0d 6d       	rlc	r13		
    fc94:	0c 8e       	sub	r14,	r12	
    fc96:	0d 7f       	subc	r15,	r13	
    fc98:	0c 5c       	rla	r12		
    fc9a:	0d 6d       	rlc	r13		
    fc9c:	0c 5a       	add	r10,	r12	
    fc9e:	0d 6b       	addc	r11,	r13	
    fca0:	0e 4c       	mov	r12,	r14	
    fca2:	0f 4d       	mov	r13,	r15	
    fca4:	0e 5e       	rla	r14		
    fca6:	0f 6f       	rlc	r15		
    fca8:	0e 5e       	rla	r14		
    fcaa:	0f 6f       	rlc	r15		
    fcac:	0e 5e       	rla	r14		
    fcae:	0f 6f       	rlc	r15		
    fcb0:	0e 5e       	rla	r14		
    fcb2:	0f 6f       	rlc	r15		
    fcb4:	0e 5e       	rla	r14		
    fcb6:	0f 6f       	rlc	r15		
    fcb8:	0e 5c       	add	r12,	r14	
    fcba:	0f 6d       	addc	r13,	r15	
    fcbc:	0e 5e       	rla	r14		
    fcbe:	0f 6f       	rlc	r15		
    fcc0:	0e 5e       	rla	r14		
    fcc2:	0f 6f       	rlc	r15		
    fcc4:	0e 8a       	sub	r10,	r14	
    fcc6:	0f 7b       	subc	r11,	r15	
    fcc8:	0e 5e       	rla	r14		
    fcca:	0f 6f       	rlc	r15		
    fccc:	0e 5e       	rla	r14		
    fcce:	0f 6f       	rlc	r15		
    fcd0:	0e 5a       	add	r10,	r14	
    fcd2:	0f 6b       	addc	r11,	r15	
    fcd4:	3e 50 39 30 	add	#12345,	r14	;#0x3039
    fcd8:	0f 63       	adc	r15		
    fcda:	89 4e 00 00 	mov	r14,	0(r9)	;0x0000(r9)
    fcde:	0f 4e       	mov	r14,	r15	
    fce0:	39 41       	pop	r9		
    fce2:	3a 41       	pop	r10		
    fce4:	3b 41       	pop	r11		
    fce6:	30 41       	ret			

0000fce8 <rand>:
    fce8:	0b 12       	push	r11		
    fcea:	0a 12       	push	r10		
    fcec:	1a 42 08 02 	mov	&0x0208,r10	
    fcf0:	1b 42 0a 02 	mov	&0x020a,r11	
    fcf4:	0e 4a       	mov	r10,	r14	
    fcf6:	0f 4b       	mov	r11,	r15	
    fcf8:	4f ee       	xor.b	r14,	r15	
    fcfa:	0f ee       	xor	r14,	r15	
    fcfc:	8f 10       	swpb	r15		
    fcfe:	7e f3       	and.b	#-1,	r14	;r3 As==11
    fd00:	8e 10       	swpb	r14		
    fd02:	0e 5e       	rla	r14		
    fd04:	0f 6f       	rlc	r15		
    fd06:	0e 8a       	sub	r10,	r14	
    fd08:	0f 7b       	subc	r11,	r15	
    fd0a:	0e 5e       	rla	r14		
    fd0c:	0f 6f       	rlc	r15		
    fd0e:	0e 5e       	rla	r14		
    fd10:	0f 6f       	rlc	r15		
    fd12:	0e 5a       	add	r10,	r14	
    fd14:	0f 6b       	addc	r11,	r15	
    fd16:	0c 4e       	mov	r14,	r12	
    fd18:	0d 4f       	mov	r15,	r13	
    fd1a:	4d ec       	xor.b	r12,	r13	
    fd1c:	0d ec       	xor	r12,	r13	
    fd1e:	8d 10       	swpb	r13		
    fd20:	7c f3       	and.b	#-1,	r12	;r3 As==11
    fd22:	8c 10       	swpb	r12		
    fd24:	0c 5c       	rla	r12		
    fd26:	0d 6d       	rlc	r13		
    fd28:	0c 8e       	sub	r14,	r12	
    fd2a:	0d 7f       	subc	r15,	r13	
    fd2c:	0c 5c       	rla	r12		
    fd2e:	0d 6d       	rlc	r13		
    fd30:	0c 5a       	add	r10,	r12	
    fd32:	0d 6b       	addc	r11,	r13	
    fd34:	0e 4c       	mov	r12,	r14	
    fd36:	0f 4d       	mov	r13,	r15	
    fd38:	0e 5e       	rla	r14		
    fd3a:	0f 6f       	rlc	r15		
    fd3c:	0e 5e       	rla	r14		
    fd3e:	0f 6f       	rlc	r15		
    fd40:	0e 5e       	rla	r14		
    fd42:	0f 6f       	rlc	r15		
    fd44:	0e 5e       	rla	r14		
    fd46:	0f 6f       	rlc	r15		
    fd48:	0e 5e       	rla	r14		
    fd4a:	0f 6f       	rlc	r15		
    fd4c:	0e 5c       	add	r12,	r14	
    fd4e:	0f 6d       	addc	r13,	r15	
    fd50:	0e 5e       	rla	r14		
    fd52:	0f 6f       	rlc	r15		
    fd54:	0e 5e       	rla	r14		
    fd56:	0f 6f       	rlc	r15		
    fd58:	0e 8a       	sub	r10,	r14	
    fd5a:	0f 7b       	subc	r11,	r15	
    fd5c:	0e 5e       	rla	r14		
    fd5e:	0f 6f       	rlc	r15		
    fd60:	0e 5e       	rla	r14		
    fd62:	0f 6f       	rlc	r15		
    fd64:	0e 5a       	add	r10,	r14	
    fd66:	0f 6b       	addc	r11,	r15	
    fd68:	3e 50 39 30 	add	#12345,	r14	;#0x3039
    fd6c:	0f 63       	adc	r15		
    fd6e:	82 4e 08 02 	mov	r14,	&0x0208	
    fd72:	82 4f 0a 02 	mov	r15,	&0x020a	
    fd76:	0f 4e       	mov	r14,	r15	
    fd78:	3a 41       	pop	r10		
    fd7a:	3b 41       	pop	r11		
    fd7c:	30 41       	ret			

0000fd7e <srand>:
    fd7e:	82 4f 08 02 	mov	r15,	&0x0208	
    fd82:	82 43 0a 02 	mov	#0,	&0x020a	;r3 As==00
    fd86:	30 41       	ret			

0000fd88 <_unexpected_>:
    fd88:	00 13       	reti			

Disassembly of section .vectors:

0000ffe0 <__ivtbl_16>:
    ffe0:	3a f9 3a f9 3a f9 3a f9 3a f9 68 f9 3a f9 3a f9     :.:.:.:.:.h.:.:.
    fff0:	ea fb b0 f9 3a f9 3a f9 3a f9 3a f9 3a f9 00 f8     ....:.:.:.:.:...
