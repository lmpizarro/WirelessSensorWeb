
main.elf:     file format elf32-msp430

SYMBOL TABLE:
0000f800 l    d  .text	00000000 .text
00000200 l    d  .data	00000000 .data
0000020c l    d  .bss	00000000 .bss
0000ffe0 l    d  .vectors	00000000 .vectors
00000000 l    d  .debug_aranges	00000000 .debug_aranges
00000000 l    d  .debug_pubnames	00000000 .debug_pubnames
00000000 l    d  .debug_info	00000000 .debug_info
00000000 l    d  .debug_abbrev	00000000 .debug_abbrev
00000000 l    d  .debug_line	00000000 .debug_line
00000000 l    d  .debug_frame	00000000 .debug_frame
00000000 l    d  .debug_str	00000000 .debug_str
00000000 l    d  .debug_loc	00000000 .debug_loc
00000000 l    d  .debug_pubtypes	00000000 .debug_pubtypes
00000000 l    d  .debug_ranges	00000000 .debug_ranges
00000000 l    df *ABS*	00000000 main.c
0000fc3c l     O .text	00000010 asciiCode
0000f932 l       .text	00000000 __br_unexpected_
00000000 l    df *ABS*	00000000 rand.c
00000208 l     O .data	00000004 next
0000007c g       *ABS*	00000000 __USISR
00000057 g       *ABS*	00000000 __BCSCTL1
00000174 g       *ABS*	00000000 __TACCR1
0000000c g       *ABS*	00000000 __data_size
0000f932  w      .text	00000000 __isr_14
0000f960 g     F .text	00000008 ADC10_ISR
0000007a g       *ABS*	00000000 __USICKCTL
00000128 g       *ABS*	00000000 __FCTL1
00000024 g       *ABS*	00000000 __P1IES
0000f932  w      .text	00000000 __isr_4
00000002 g       *ABS*	00000000 __IFG1
0000f9f6 g     F .text	00000122 TransmitADCValue
0000012e g       *ABS*	00000000 __TAIV
00000000 g       .vectors	00000000 _efartext
0000002b g       *ABS*	00000000 __P2IFG
0000fb18 g     F .text	000000ca genRand03
0000fd82 g       *ABS*	00000000 _etext
0000f9a8 g     F .text	0000004e Timer_A
00000006 g       *ABS*	00000000 __bss_size
00000078 g       *ABS*	00000000 __USICTL
0000f92c  w      .text	00000000 __stop_progExec__
0000002d g       *ABS*	00000000 __P2IE
0000f932  w      .text	00000000 __isr_11
00000025 g       *ABS*	00000000 __P1IE
00000049 g       *ABS*	00000000 __ADC10DTC1
0000f960 g       .text	00000000 __isr_5
0000fd82 g       *ABS*	00000000 __data_load_start
0000f932 g       .text	00000000 __dtors_end
00000053 g       *ABS*	00000000 __BCSCTL3
000001bc g       *ABS*	00000000 __ADC10SA
0000007a g       *ABS*	00000000 __USICCTL
0000f932  w      .text	00000000 __isr_2
0000f968 g     F .text	00000040 Transmit
00000160 g       *ABS*	00000000 __TACTL
0000012c g       *ABS*	00000000 __FCTL3
0000f932  w      .text	00000000 __isr_10
0000002e g       *ABS*	00000000 __P2SEL
00000023 g       *ABS*	00000000 __P1IFG
0000004a g       *ABS*	00000000 __ADC10AE0
00000172 g       *ABS*	00000000 __TACCR0
00000056 g       *ABS*	00000000 __DCOCTL
0000fc34 g     O .text	00000001 deviceID
0000f932  w      .text	00000000 __isr_7
0000ffe0 g     O .vectors	00000020 __ivtbl_16
0000fc4c g     F .text	00000094 rand_r
00000028 g       *ABS*	00000000 __P2IN
0000f936 g     F .text	0000001a ConfigureAdcTempSensor
000001b4 g       *ABS*	00000000 __ADC10MEM
0000fbe2 g     F .text	00000016 Timer_A1
0000f932  w      .text	00000000 __isr_0
00000029 g       *ABS*	00000000 __P2OUT
0000012a g       *ABS*	00000000 __FCTL2
0000f824  w      .text	00000000 __do_clear_bss
00000021 g       *ABS*	00000000 __P1OUT
0000fbf8 g     F .text	0000002a setVloClk
0000002c g       *ABS*	00000000 __P2IES
00000026 g       *ABS*	00000000 __P1SEL
0000020c g     O .bss	00000001 ADCDone
0000fce0 g     F .text	00000096 rand
00000079 g       *ABS*	00000000 __USICTL1
00000027 g       *ABS*	00000000 __P1REN
0000fd80  w      .text	00000000 _unexpected_
0000fbe2 g       .text	00000000 __isr_8
00000200 g     O .data	00000004 sampleTimeSec
0000f932  w      .text	00000000 __isr_3
0000f800  w      .text	00000000 _reset_vector__
0000f932 g       .text	00000000 __ctors_start
0000f932  w      .text	00000000 __isr_12
0000f80e  w      .text	00000000 __do_copy_data
00000204 g     O .data	00000004 dlyCC1
0000020c g       .bss	00000000 __bss_start
0000020d g     O .bss	00000001 BitCnt
0000f838 g     F .text	000000f4 main
0000020e g     O .bss	00000002 TXByte
0000fd76 g     F .text	0000000a srand
0000f932  w      .text	00000000 __isr_13
00000170 g       *ABS*	00000000 __TAR
00000162 g       *ABS*	00000000 __TACCTL0
00010000 g       .vectors	00000000 _vectors_end
0000002a g       *ABS*	00000000 __P2DIR
0000002f g       *ABS*	00000000 __P2REN
0000007d g       *ABS*	00000000 __USISRH
0000f950 g     F .text	00000010 adqAdcTempSensor
00000210 g     O .bss	00000002 ADCValue
000001b0 g       *ABS*	00000000 __ADC10CTL0
0000f9a8 g       .text	00000000 __isr_9
000010fe g       *ABS*	00000000 __CALDCO_1MHZ
0000f800  w      .text	00000000 __init_stack
0000f932 g       .text	00000000 __dtors_start
0000f932  w      .text	00000000 __isr_6
0000f932 g       .text	00000000 __ctors_end
00000280 g       *ABS*	00000000 __stack
0000f932  w      .text	00000000 __isr_1
0000020c g       .data	00000000 _edata
00000212 g       .bss	00000000 _end
0000007b g       *ABS*	00000000 __USICNT
00000048 g       *ABS*	00000000 __ADC10DTC0
000001b2 g       *ABS*	00000000 __ADC10CTL1
00000058 g       *ABS*	00000000 __BCSCTL2
0000f92c  w      .text	00000000 _endless_loop__
00000022 g       *ABS*	00000000 __P1DIR
00000164 g       *ABS*	00000000 __TACCTL1
0000fc3a g     O .text	00000002 Bitime
000010ff g       *ABS*	00000000 __CALBC1_1MHZ
0000fc36 g     O .text	00000004 minTime
0000f804  w      .text	00000000 __low_level_init
0000fc22 g     F .text	00000012 setClockTrans
00000200 g       .data	00000000 __data_start
00000120 g       *ABS*	00000000 __WDTCTL
00000000 g       *ABS*	00000000 __IE1
00000078 g       *ABS*	00000000 __USICTL0
00000020 g       *ABS*	00000000 __P1IN
0000007c g       *ABS*	00000000 __USISRL



Disassembly of section .text:

0000f800 <__init_stack>:
    f800:	31 40 80 02 	mov	#640,	r1	;#0x0280

0000f804 <__low_level_init>:
    f804:	15 42 20 01 	mov	&0x0120,r5	
    f808:	75 f3       	and.b	#-1,	r5	;r3 As==11
    f80a:	35 d0 08 5a 	bis	#23048,	r5	;#0x5a08

0000f80e <__do_copy_data>:
    f80e:	3f 40 0c 00 	mov	#12,	r15	;#0x000c
    f812:	0f 93       	tst	r15		
    f814:	07 24       	jz	$+16     	;abs 0xf824
    f816:	82 45 20 01 	mov	r5,	&0x0120	
    f81a:	2f 83       	decd	r15		
    f81c:	9f 4f 82 fd 	mov	-638(r15),512(r15);0xfd82(r15), 0x0200(r15)
    f820:	00 02 
    f822:	f9 23       	jnz	$-12     	;abs 0xf816

0000f824 <__do_clear_bss>:
    f824:	3f 40 06 00 	mov	#6,	r15	;#0x0006
    f828:	0f 93       	tst	r15		
    f82a:	06 24       	jz	$+14     	;abs 0xf838
    f82c:	82 45 20 01 	mov	r5,	&0x0120	
    f830:	1f 83       	dec	r15		
    f832:	cf 43 0c 02 	mov.b	#0,	524(r15);r3 As==00, 0x020c(r15)
    f836:	fa 23       	jnz	$-10     	;abs 0xf82c

0000f838 <main>:


void main (){
  long int tSampleMs, auxTimeMs;

  WDTCTL = WDTPW + WDTHOLD;                // Stop watchdog timer
    f838:	b2 40 80 5a 	mov	#23168,	&0x0120	;#0x5a80
    f83c:	20 01 
  P1SEL |= TXD + APC220_CTL;
    f83e:	f2 d0 03 00 	bis.b	#3,	&0x0026	;#0x0003
    f842:	26 00 
  P1DIR |= 0x40 + TXD + APC220_CTL;                           // Set P1.0  y P1.6 to output direction
    f844:	f2 d0 43 00 	bis.b	#67,	&0x0022	;#0x0043
    f848:	22 00 
  P1REN &= ~APC220_CTL;
    f84a:	f2 f0 fe ff 	and.b	#-2,	&0x0027	;#0xfffe
    f84e:	27 00 
  
  //P1OUT = 0x00;

    ConfigureAdcTempSensor();
    f850:	b0 12 36 f9 	call	#0xf936	

    __enable_interrupt();                     // Enable interrupts.
    f854:	32 d2       	eint			

    BCSCTL1 |= DIVA_0;                               // ACLK / 8
    BCSCTL2 |= SELM_3 + DIVM_3 + SELS + DIVS_3;               // MCLK = LFXT1/8
    f856:	f2 d0 fe ff 	bis.b	#-2,	&0x0058	;#0xfffe
    f85a:	58 00 
    BCSCTL3 |= LFXT1S_2;                      // LFXT1 = VLO
    f85c:	f2 d0 20 00 	bis.b	#32,	&0x0053	;#0x0020
    f860:	53 00 
    IFG1 &= ~OFIFG;                           // Clear OSCFault flag
    f862:	f2 f0 fd ff 	and.b	#-3,	&0x0002	;#0xfffd
    f866:	02 00 
    __bis_SR_register(SCG1 + SCG0);           // Stop DCO
    f868:	32 d0 c0 00 	bis	#192,	r2	;#0x00c0


    CCTL1 = CCIE;                            // interrupt enabled CC1
    f86c:	b2 40 10 00 	mov	#16,	&0x0164	;#0x0010
    f870:	64 01 
    CCR1 = dlyCC1;
    f872:	92 42 04 02 	mov	&0x0204,&0x0174	
    f876:	74 01 
    TACTL = TASSEL_1 + MC_2;                 // ACLK, upmode
    f878:	b2 40 20 01 	mov	#288,	&0x0160	;#0x0120
    f87c:	60 01 
   
    srand(deviceID); 
    f87e:	3f 40 23 00 	mov	#35,	r15	;#0x0023
    f882:	b0 12 76 fd 	call	#0xfd76	
  // 60000 ciclos 5 segundos
  // 12000 ciclos 1 segundo
  //
  // 12    ciclos 1 mS
  //
  sampleTimeSec =  10;
    f886:	b2 40 0a 00 	mov	#10,	&0x0200	;#0x000a
    f88a:	00 02 
    f88c:	82 43 02 02 	mov	#0,	&0x0202	;r3 As==00
  tSampleMs = sampleTimeSec * 1000;

  auxTimeMs = genRand03(tSampleMs);
    f890:	3e 40 10 27 	mov	#10000,	r14	;#0x2710
    f894:	0f 43       	clr	r15		
    f896:	b0 12 18 fb 	call	#0xfb18	
    f89a:	0a 4e       	mov	r14,	r10	
    f89c:	0b 4f       	mov	r15,	r11	
  while(1){
    if (auxTimeMs > minTime) {
    f89e:	38 40 88 13 	mov	#5000,	r8	;#0x1388
    f8a2:	09 43       	clr	r9		
    f8a4:	0b 93       	tst	r11		
    f8a6:	02 20       	jnz	$+6      	;abs 0xf8ac
    f8a8:	08 9a       	cmp	r10,	r8	
    f8aa:	09 2c       	jc	$+20     	;abs 0xf8be
         //P1OUT |= 0x01;                           // 0100|0001 = 0x41 pone en 1 P1.0 y P1.6
         //P1OUT &= ~0x01;                           // 0100|0001 = 0x41 pone en 1 P1.0 y P1.6
      auxTimeMs = auxTimeMs - minTime;
    f8ac:	3a 50 78 ec 	add	#-5000,	r10	;#0xec78
    f8b0:	3b 63       	addc	#-1,	r11	;r3 As==11
      _BIS_SR(LPM3_bits + GIE);                // Enter LPM3 w/ interrupt
    f8b2:	32 d0 d8 00 	bis	#216,	r2	;#0x00d8
  sampleTimeSec =  10;
  tSampleMs = sampleTimeSec * 1000;

  auxTimeMs = genRand03(tSampleMs);
  while(1){
    if (auxTimeMs > minTime) {
    f8b6:	0b 93       	tst	r11		
    f8b8:	f9 23       	jnz	$-12     	;abs 0xf8ac
    f8ba:	08 9a       	cmp	r10,	r8	
    f8bc:	f7 2b       	jnc	$-16     	;abs 0xf8ac
         //P1OUT |= 0x01;                           // 0100|0001 = 0x41 pone en 1 P1.0 y P1.6
         //P1OUT &= ~0x01;                           // 0100|0001 = 0x41 pone en 1 P1.0 y P1.6
      auxTimeMs = auxTimeMs - minTime;
      _BIS_SR(LPM3_bits + GIE);                // Enter LPM3 w/ interrupt
    }else {
      if (auxTimeMs == 0){
    f8be:	0a 93       	tst	r10		
    f8c0:	09 24       	jz	$+20     	;abs 0xf8d4
         CCTL0 &= ~CCIE;                            // interrupt disabled CC0
         CCR1 = dlyCC1;
         setVloClk();
 
     } else {
       CCR1 = auxTimeMs * 12;
    f8c2:	0f 4a       	mov	r10,	r15	
    f8c4:	0f 5f       	rla	r15		
    f8c6:	0f 5a       	add	r10,	r15	
    f8c8:	0f 5f       	rla	r15		
    f8ca:	0f 5f       	rla	r15		
    f8cc:	82 4f 74 01 	mov	r15,	&0x0174	
       auxTimeMs = 0;
       _BIS_SR(LPM3_bits + GIE);                // Enter LPM3 w/ interrupt
    f8d0:	32 d0 d8 00 	bis	#216,	r2	;#0x00d8
         //P1OUT &= ~0x01;                           // 0100|0001 = 0x41 pone en 1 P1.0 y P1.6
      auxTimeMs = auxTimeMs - minTime;
      _BIS_SR(LPM3_bits + GIE);                // Enter LPM3 w/ interrupt
    }else {
      if (auxTimeMs == 0){
         CCTL1 &= ~CCIE;                            // interrupt disabled CC1
    f8d4:	b2 f0 ef ff 	and	#-17,	&0x0164	;#0xffef
    f8d8:	64 01 

}

void setClockTrans(){

    BCSCTL1 = CALBC1_1MHZ;           // Set range
    f8da:	d2 42 ff 10 	mov.b	&0x10ff,&0x0057	
    f8de:	57 00 
    DCOCTL = CALDCO_1MHZ;            // SMCLK = DCO = 1MHz
    f8e0:	d2 42 fe 10 	mov.b	&0x10fe,&0x0056	
    f8e4:	56 00 
    //BCSCTL2 |= SELM_1 + DIVM_0;               // MCLK = LFXT1/8
    BCSCTL2 = 0x00;               // MCLK = LFXT1/8
    f8e6:	c2 43 58 00 	mov.b	#0,	&0x0058	;r3 As==00
    }else {
      if (auxTimeMs == 0){
         CCTL1 &= ~CCIE;                            // interrupt disabled CC1
         setClockTrans();

         auxTimeMs = genRand03(tSampleMs);
    f8ea:	3e 40 10 27 	mov	#10000,	r14	;#0x2710
    f8ee:	0f 43       	clr	r15		
    f8f0:	b0 12 18 fb 	call	#0xfb18	
    f8f4:	0a 4e       	mov	r14,	r10	
    f8f6:	0b 4f       	mov	r15,	r11	

         ADCValue = adqAdcTempSensor();
    f8f8:	b0 12 50 f9 	call	#0xf950	
    f8fc:	82 4f 10 02 	mov	r15,	&0x0210	
         P1OUT = 0x41;                           // 0100|0001 = 0x41 pone en 1 P1.0 y P1.6
    f900:	f2 40 41 00 	mov.b	#65,	&0x0021	;#0x0041
    f904:	21 00 
         int i;
         for (i = 0; i < 1; i++) __delay_cycles(500);
    f906:	3f 40 a6 00 	mov	#166,	r15	;#0x00a6
    f90a:	1f 83       	dec	r15		
    f90c:	fe 23       	jnz	$-2      	;abs 0xf90a

         TransmitADCValue (deviceID);
    f90e:	3f 40 23 00 	mov	#35,	r15	;#0x0023
    f912:	b0 12 f6 f9 	call	#0xf9f6	
         P1OUT = 0x00;                          // 1011|1110 = 0xFE pone en 0 P1.0 
    f916:	c2 43 21 00 	mov.b	#0,	&0x0021	;r3 As==00

         CCTL0 &= ~CCIE;                            // interrupt disabled CC0
    f91a:	b2 f0 ef ff 	and	#-17,	&0x0162	;#0xffef
    f91e:	62 01 
         CCR1 = dlyCC1;
    f920:	92 42 04 02 	mov	&0x0204,&0x0174	
    f924:	74 01 
         setVloClk();
    f926:	b0 12 f8 fb 	call	#0xfbf8	
    f92a:	bc 3f       	jmp	$-134    	;abs 0xf8a4

0000f92c <__stop_progExec__>:
    f92c:	32 d0 f0 00 	bis	#240,	r2	;#0x00f0
    f930:	fd 3f       	jmp	$-4      	;abs 0xf92c

0000f932 <__ctors_end>:
    f932:	30 40 80 fd 	br	#0xfd80	

0000f936 <ConfigureAdcTempSensor>:
/* Configure ADC Temp Sensor Channel */
void ConfigureAdcTempSensor(void)
{
//  unsigned char i;
  ADC10CTL1 = INCH_10 + ADC10DIV_3;         // Temp Sensor ADC10CLK/4
    f936:	b2 40 60 a0 	mov	#-24480,&0x01b2	;#0xa060
    f93a:	b2 01 
  ADC10CTL0 = SREF_1 + ADC10SHT_3 + REFON + ADC10ON + ADC10IE;
    f93c:	b2 40 38 38 	mov	#14392,	&0x01b0	;#0x3838
    f940:	b0 01 
  __delay_cycles(1000);                     // Wait for ADC Ref to settle
    f942:	03 43       	nop			
    f944:	03 43       	nop			
    f946:	3f 40 4c 01 	mov	#332,	r15	;#0x014c
    f94a:	1f 83       	dec	r15		
    f94c:	fe 23       	jnz	$-2      	;abs 0xf94a
//  __bis_SR_register(CPUOFF + GIE);          // LPM0 with interrupts enabled
//  tempCalibrated = ADC10MEM;
//  for (i=0; i < 8; i++)
//    tempMeasured[i] = tempCalibrated;
//  tempAverage = tempCalibrated;
}
    f94e:	30 41       	ret			

0000f950 <adqAdcTempSensor>:

int  adqAdcTempSensor(void)
{
   ADC10CTL0 |= ENC + ADC10SC;             // Sampling and conversion start
    f950:	b2 d0 03 00 	bis	#3,	&0x01b0	;#0x0003
    f954:	b0 01 
    __bis_SR_register(CPUOFF + GIE);        // LPM0 with interrupts enabled
    f956:	32 d0 18 00 	bis	#24,	r2	;#0x0018
   return (ADC10MEM);
}
    f95a:	1f 42 b4 01 	mov	&0x01b4,r15	
    f95e:	30 41       	ret			

0000f960 <ADC10_ISR>:

// ADC10 interrupt service routine
interrupt (ADC10_VECTOR) ADC10_ISR(void)
{
  __bic_SR_register_on_exit(CPUOFF);        // Return to active mode
    f960:	b1 c0 10 00 	bic	#16,	0(r1)	;#0x0010, 0x0000(r1)
    f964:	00 00 
}
    f966:	00 13       	reti			

0000f968 <Transmit>:


// Function Transmits Character from TXByte
void Transmit()
{
  CCTL0 = OUT;                               // TXD Idle as Mark
    f968:	a2 42 62 01 	mov	#4,	&0x0162	;r2 As==10
  TACTL = TASSEL_2 + MC_2;               // SMCLK, continuous mode
    f96c:	b2 40 20 02 	mov	#544,	&0x0160	;#0x0220
    f970:	60 01 

  BitCnt = 0xA;                       // Load Bit counter, 8 bits + ST/SP
    f972:	f2 40 0a 00 	mov.b	#10,	&0x020d	;#0x000a
    f976:	0d 02 
  CCR0 = TAR;
    f978:	92 42 70 01 	mov	&0x0170,&0x0172	
    f97c:	72 01 

  CCR0 += Bitime;                  // Set time till first bit
    f97e:	b2 50 68 00 	add	#104,	&0x0172	;#0x0068
    f982:	72 01 
  TXByte |= 0x100;                 // Add stop bit to TXByte (which is logical 1)
  TXByte = TXByte << 1;            // Add start bit (which is logical 0)
    f984:	1f 42 0e 02 	mov	&0x020e,r15	
    f988:	3f d0 00 01 	bis	#256,	r15	;#0x0100
    f98c:	0f 5f       	rla	r15		
    f98e:	82 4f 0e 02 	mov	r15,	&0x020e	


  CCTL0 =  CCIS0 + OUTMOD0 + CCIE; // Set signal, intial value, enable interrupts
    f992:	b2 40 30 10 	mov	#4144,	&0x0162	;#0x1030
    f996:	62 01 
  while ( CCTL0 & CCIE );          // Wait for TX completion
    f998:	b2 b0 10 00 	bit	#16,	&0x0162	;#0x0010
    f99c:	62 01 
    f99e:	fc 23       	jnz	$-6      	;abs 0xf998
  TACTL = TASSEL_2;             // SMCLK, timer off (for power consumption)
    f9a0:	b2 40 00 02 	mov	#512,	&0x0160	;#0x0200
    f9a4:	60 01 
  
}
    f9a6:	30 41       	ret			

0000f9a8 <Timer_A>:

// Timer A0 interrupt service routine
interrupt (TIMERA0_VECTOR) Timer_A (void)
{ 
    f9a8:	0f 12       	push	r15		
    f9aa:	0e 12       	push	r14		
    f9ac:	0d 12       	push	r13		

  CCR0 += Bitime;     // Add Offset to CCR0
    f9ae:	b2 50 68 00 	add	#104,	&0x0172	;#0x0068
    f9b2:	72 01 
  if ( BitCnt == 0)     // If all bits TXed, disable interrupt
    f9b4:	5f 42 0d 02 	mov.b	&0x020d,r15	
    f9b8:	4f 93       	tst.b	r15		
    f9ba:	16 24       	jz	$+46     	;abs 0xf9e8
    CCTL0 &= ~ CCIE ;
  else
  {
    CCTL0 |=  OUTMOD2;                    // TX Space
    f9bc:	b2 d0 80 00 	bis	#128,	&0x0162	;#0x0080
    f9c0:	62 01 
    if (TXByte & 0x01)
    f9c2:	1e 42 0e 02 	mov	&0x020e,r14	
    f9c6:	1e b3       	bit	#1,	r14	;r3 As==01
    f9c8:	0b 20       	jnz	$+24     	;abs 0xf9e0
      CCTL0 &= ~ OUTMOD2;                   // TX Mark
    TXByte = TXByte >> 1;
    f9ca:	12 c3       	clrc			
    f9cc:	0e 10       	rrc	r14		
    f9ce:	82 4e 0e 02 	mov	r14,	&0x020e	
    BitCnt --;
    f9d2:	7f 53       	add.b	#-1,	r15	;r3 As==11
    f9d4:	c2 4f 0d 02 	mov.b	r15,	&0x020d	
  }
}
    f9d8:	3d 41       	pop	r13		
    f9da:	3e 41       	pop	r14		
    f9dc:	3f 41       	pop	r15		
    f9de:	00 13       	reti			
    CCTL0 &= ~ CCIE ;
  else
  {
    CCTL0 |=  OUTMOD2;                    // TX Space
    if (TXByte & 0x01)
      CCTL0 &= ~ OUTMOD2;                   // TX Mark
    f9e0:	b2 f0 7f ff 	and	#-129,	&0x0162	;#0xff7f
    f9e4:	62 01 
    f9e6:	f1 3f       	jmp	$-28     	;abs 0xf9ca
interrupt (TIMERA0_VECTOR) Timer_A (void)
{ 

  CCR0 += Bitime;     // Add Offset to CCR0
  if ( BitCnt == 0)     // If all bits TXed, disable interrupt
    CCTL0 &= ~ CCIE ;
    f9e8:	b2 f0 ef ff 	and	#-17,	&0x0162	;#0xffef
    f9ec:	62 01 
    if (TXByte & 0x01)
      CCTL0 &= ~ OUTMOD2;                   // TX Mark
    TXByte = TXByte >> 1;
    BitCnt --;
  }
}
    f9ee:	3d 41       	pop	r13		
    f9f0:	3e 41       	pop	r14		
    f9f2:	3f 41       	pop	r15		
    f9f4:	00 13       	reti			

0000f9f6 <TransmitADCValue>:
bool ADCDone;                   // ADC Done flag

#define codFunc       4


void TransmitADCValue (unsigned int SensorId){
    f9f6:	0b 12       	push	r11		
    f9f8:	0a 12       	push	r10		
    f9fa:	09 12       	push	r9		
    f9fc:	08 12       	push	r8		
    f9fe:	07 12       	push	r7		
    fa00:	0b 4f       	mov	r15,	r11	
  unsigned int cksum = 0;

  /*************************************************************/  
  // Transmitir Comienzo  de Mensaje ':'
  /*************************************************************/  
   TXByte = ':';
    fa02:	b2 40 3a 00 	mov	#58,	&0x020e	;#0x003a
    fa06:	0e 02 
   cksum = cksum + TXByte;
   Transmit();
    fa08:	b0 12 68 f9 	call	#0xf968	

  /*************************************************************/  
  //  Transmitir el SensorId
  /*************************************************************/  

   TXByte = (SensorId >> 4) & 0x000F;
    fa0c:	0e 4b       	mov	r11,	r14	
    fa0e:	12 c3       	clrc			
    fa10:	0e 10       	rrc	r14		
    fa12:	0e 11       	rra	r14		
    fa14:	0e 11       	rra	r14		
    fa16:	0e 11       	rra	r14		
    fa18:	3e f0 0f 00 	and	#15,	r14	;#0x000f
   TXByte  = asciiCode[TXByte];
    fa1c:	5a 4e 3c fc 	mov.b	-964(r14),r10	;0xfc3c(r14)
    fa20:	8a 11       	sxt	r10		
    fa22:	82 4a 0e 02 	mov	r10,	&0x020e	
   cksum = cksum + TXByte;
   Transmit();                                           // Send
    fa26:	b0 12 68 f9 	call	#0xf968	


  TXByte = SensorId & 0x000F;
    fa2a:	3b f0 0f 00 	and	#15,	r11	;#0x000f
  TXByte  = asciiCode[TXByte];
    fa2e:	59 4b 3c fc 	mov.b	-964(r11),r9	;0xfc3c(r11)
    fa32:	89 11       	sxt	r9		
    fa34:	82 49 0e 02 	mov	r9,	&0x020e	
  cksum = cksum + TXByte;
  Transmit();                                           // Send
    fa38:	b0 12 68 f9 	call	#0xf968	

  /*************************************************************/  
  // Transmitir el codFunc 
  /*************************************************************/  
  TXByte = (codFunc >> 4) & 0x000F;
  TXByte  = asciiCode[TXByte];
    fa3c:	b2 40 30 00 	mov	#48,	&0x020e	;#0x0030
    fa40:	0e 02 
  cksum = cksum + TXByte;
  Transmit();                                           // Send
    fa42:	b0 12 68 f9 	call	#0xf968	


  TXByte = codFunc & 0x000F;
  TXByte  = asciiCode[TXByte];
    fa46:	b2 40 34 00 	mov	#52,	&0x020e	;#0x0034
    fa4a:	0e 02 
  cksum = cksum + TXByte;
  Transmit();                                           // Send
    fa4c:	b0 12 68 f9 	call	#0xf968	


  /*************************************************************/  
  // Transmitir el valor del ADC
  /*************************************************************/
  TXByte = (ADCValue>>12) & 0x000F;
    fa50:	1f 42 10 02 	mov	&0x0210,r15	
    fa54:	8f 10       	swpb	r15		
    fa56:	3f f0 ff 00 	and	#255,	r15	;#0x00ff
    fa5a:	12 c3       	clrc			
    fa5c:	0f 10       	rrc	r15		
    fa5e:	0f 11       	rra	r15		
    fa60:	0f 11       	rra	r15		
    fa62:	0f 11       	rra	r15		
  TXByte  = asciiCode[TXByte];
    fa64:	5b 4f 3c fc 	mov.b	-964(r15),r11	;0xfc3c(r15)
    fa68:	8b 11       	sxt	r11		
    fa6a:	82 4b 0e 02 	mov	r11,	&0x020e	
  cksum = cksum + TXByte;
  Transmit();                                           // Send
    fa6e:	b0 12 68 f9 	call	#0xf968	

  TXByte = (ADCValue>>8) & 0x000F;
    fa72:	1f 42 10 02 	mov	&0x0210,r15	
    fa76:	8f 10       	swpb	r15		
    fa78:	3f f0 0f 00 	and	#15,	r15	;#0x000f
  TXByte  = asciiCode[TXByte];
    fa7c:	57 4f 3c fc 	mov.b	-964(r15),r7	;0xfc3c(r15)
    fa80:	87 11       	sxt	r7		
    fa82:	82 47 0e 02 	mov	r7,	&0x020e	
  cksum = cksum + TXByte;
  Transmit();                                           // Send
    fa86:	b0 12 68 f9 	call	#0xf968	

  TXByte = (ADCValue >> 4) & 0x000F;
    fa8a:	1f 42 10 02 	mov	&0x0210,r15	
    fa8e:	12 c3       	clrc			
    fa90:	0f 10       	rrc	r15		
    fa92:	0f 11       	rra	r15		
    fa94:	0f 11       	rra	r15		
    fa96:	0f 11       	rra	r15		
    fa98:	3f f0 0f 00 	and	#15,	r15	;#0x000f
  TXByte  = asciiCode[TXByte];
    fa9c:	58 4f 3c fc 	mov.b	-964(r15),r8	;0xfc3c(r15)
    faa0:	88 11       	sxt	r8		
    faa2:	82 48 0e 02 	mov	r8,	&0x020e	
  cksum = cksum + TXByte;
  Transmit();                                           // Send
    faa6:	b0 12 68 f9 	call	#0xf968	

  TXByte = ADCValue & 0x000F;
    faaa:	1f 42 10 02 	mov	&0x0210,r15	
    faae:	3f f0 0f 00 	and	#15,	r15	;#0x000f
  TXByte  = asciiCode[TXByte];
    fab2:	5f 4f 3c fc 	mov.b	-964(r15),r15	;0xfc3c(r15)
    fab6:	8f 11       	sxt	r15		
    fab8:	82 4f 0e 02 	mov	r15,	&0x020e	
  /*************************************************************/  
  // Transmitir el codFunc 
  /*************************************************************/  
  TXByte = (codFunc >> 4) & 0x000F;
  TXByte  = asciiCode[TXByte];
  cksum = cksum + TXByte;
    fabc:	0b 5f       	add	r15,	r11	
  Transmit();                                           // Send


  TXByte = codFunc & 0x000F;
  TXByte  = asciiCode[TXByte];
  cksum = cksum + TXByte;
    fabe:	3b 50 9e 00 	add	#158,	r11	;#0x009e
  /*************************************************************/  
  // Transmitir el valor del ADC
  /*************************************************************/
  TXByte = (ADCValue>>12) & 0x000F;
  TXByte  = asciiCode[TXByte];
  cksum = cksum + TXByte;
    fac2:	0b 57       	add	r7,	r11	
  Transmit();                                           // Send

  TXByte = (ADCValue>>8) & 0x000F;
  TXByte  = asciiCode[TXByte];
  cksum = cksum + TXByte;
    fac4:	0b 58       	add	r8,	r11	
  Transmit();                                           // Send

  TXByte = (ADCValue >> 4) & 0x000F;
  TXByte  = asciiCode[TXByte];
  cksum = cksum + TXByte;
    fac6:	0b 59       	add	r9,	r11	
  Transmit();                                           // Send

  TXByte = ADCValue & 0x000F;
  TXByte  = asciiCode[TXByte];
  cksum = cksum + TXByte;
    fac8:	0b 5a       	add	r10,	r11	
  Transmit();                                           // Send
    faca:	b0 12 68 f9 	call	#0xf968	

  /*************************************************************/  
  // Transmitir el cksum
  /*************************************************************/  

  TXByte = (cksum >> 4) & 0x000F;
    face:	0f 4b       	mov	r11,	r15	
    fad0:	12 c3       	clrc			
    fad2:	0f 10       	rrc	r15		
    fad4:	0f 11       	rra	r15		
    fad6:	0f 11       	rra	r15		
    fad8:	0f 11       	rra	r15		
    fada:	3f f0 0f 00 	and	#15,	r15	;#0x000f
  TXByte  = asciiCode[TXByte];
    fade:	3a 40 0e 02 	mov	#526,	r10	;#0x020e
    fae2:	da 4f 3c fc 	mov.b	-964(r15),0(r10)	;0xfc3c(r15), 0x0000(r10)
    fae6:	00 00 
    fae8:	92 11 0e 02 	sxt	&0x020e	
  Transmit();                                           // Send
    faec:	b0 12 68 f9 	call	#0xf968	

  TXByte = cksum & 0x000F;
    faf0:	3b f0 0f 00 	and	#15,	r11	;#0x000f
  TXByte  = asciiCode[TXByte];
    faf4:	da 4b 3c fc 	mov.b	-964(r11),0(r10)	;0xfc3c(r11), 0x0000(r10)
    faf8:	00 00 
    fafa:	92 11 0e 02 	sxt	&0x020e	
  Transmit();                                           // Send
    fafe:	b0 12 68 f9 	call	#0xf968	

  /*************************************************************/  
   // Transmitir Fin de Mensaje '!'
  /*************************************************************/  
   TXByte = '!';
    fb02:	b2 40 21 00 	mov	#33,	&0x020e	;#0x0021
    fb06:	0e 02 
   Transmit();
    fb08:	b0 12 68 f9 	call	#0xf968	
}
    fb0c:	37 41       	pop	r7		
    fb0e:	38 41       	pop	r8		
    fb10:	39 41       	pop	r9		
    fb12:	3a 41       	pop	r10		
    fb14:	3b 41       	pop	r11		
    fb16:	30 41       	ret			

0000fb18 <genRand03>:
#include  <limits.h>
#include  "defs.h"

#define genRand02()  (rand ()%tSampleMs + (tSampleMs));
//#define genRand03()  ((rand ()+INT_MAX)%tSampleMs) + tSampleMs/2;
long int  genRand03(long int tSampleMs)  {
    fb18:	0b 12       	push	r11		
    fb1a:	0a 12       	push	r10		
    fb1c:	09 12       	push	r9		
    fb1e:	0a 4e       	mov	r14,	r10	
    fb20:	0b 4f       	mov	r15,	r11	
  //return(  (rand ()+INT_MAX)%tSampleMs + tSampleMs/2);
  int c;
  switch (sampleTimeSec){
    fb22:	1f 42 00 02 	mov	&0x0200,r15	
    fb26:	1e 42 02 02 	mov	&0x0202,r14	
    fb2a:	3f 90 14 00 	cmp	#20,	r15	;#0x0014
    fb2e:	3c 24       	jz	$+122    	;abs 0xfba8
    fb30:	0e 93       	tst	r14		
    fb32:	21 20       	jnz	$+68     	;abs 0xfb76
    fb34:	3f 90 15 00 	cmp	#21,	r15	;#0x0015
    fb38:	1e 2c       	jc	$+62     	;abs 0xfb76
    fb3a:	3f 90 05 00 	cmp	#5,	r15	;#0x0005
    fb3e:	3f 24       	jz	$+128    	;abs 0xfbbe
    fb40:	3f 90 0a 00 	cmp	#10,	r15	;#0x000a
    fb44:	39 24       	jz	$+116    	;abs 0xfbb8
    break; 
    case 60:
     c = 0;
    break; 
    default :
     c = 0;
    fb46:	09 43       	clr	r9		
    break; 
  };

  int x = rand ();
    fb48:	b0 12 e0 fc 	call	#0xfce0	
  int s = (x > 0) ? 1 : ((x < 0) ? -1 : 0);
    fb4c:	1f 93       	cmp	#1,	r15	;r3 As==01
    fb4e:	20 38       	jl	$+66     	;abs 0xfb90
    fb50:	09 93       	tst	r9		
    fb52:	03 24       	jz	$+8      	;abs 0xfb5a
    fb54:	0f 11       	rra	r15		
    fb56:	19 83       	dec	r9		
    fb58:	fd 23       	jnz	$-4      	;abs 0xfb54
    fb5a:	0d 4f       	mov	r15,	r13	
    fb5c:	0e 4f       	mov	r15,	r14	
    fb5e:	8e 10       	swpb	r14		
    fb60:	8e 11       	sxt	r14		
    fb62:	8e 10       	swpb	r14		
    fb64:	8e 11       	sxt	r14		

  return(((long int )(s)*(x>>c) + tSampleMs));
};
    fb66:	0f 4e       	mov	r14,	r15	
    fb68:	0e 4d       	mov	r13,	r14	
    fb6a:	0e 5a       	add	r10,	r14	
    fb6c:	0f 6b       	addc	r11,	r15	
    fb6e:	39 41       	pop	r9		
    fb70:	3a 41       	pop	r10		
    fb72:	3b 41       	pop	r11		
    fb74:	30 41       	ret			
#define genRand02()  (rand ()%tSampleMs + (tSampleMs));
//#define genRand03()  ((rand ()+INT_MAX)%tSampleMs) + tSampleMs/2;
long int  genRand03(long int tSampleMs)  {
  //return(  (rand ()+INT_MAX)%tSampleMs + tSampleMs/2);
  int c;
  switch (sampleTimeSec){
    fb76:	3f 90 1e 00 	cmp	#30,	r15	;#0x001e
    fb7a:	1a 24       	jz	$+54     	;abs 0xfbb0
    fb7c:	3f 90 3c 00 	cmp	#60,	r15	;#0x003c
    fb80:	e2 23       	jnz	$-58     	;abs 0xfb46
    fb82:	0e 93       	tst	r14		
    fb84:	e0 23       	jnz	$-62     	;abs 0xfb46
    break; 
    case 30:
     c = 1;
    break; 
    case 60:
     c = 0;
    fb86:	09 4e       	mov	r14,	r9	
    default :
     c = 0;
    break; 
  };

  int x = rand ();
    fb88:	b0 12 e0 fc 	call	#0xfce0	
  int s = (x > 0) ? 1 : ((x < 0) ? -1 : 0);
    fb8c:	1f 93       	cmp	#1,	r15	;r3 As==01
    fb8e:	e0 37       	jge	$-62     	;abs 0xfb50
    fb90:	0f 93       	tst	r15		
    fb92:	17 20       	jnz	$+48     	;abs 0xfbc2
    fb94:	0d 43       	clr	r13		
    fb96:	0e 43       	clr	r14		

  return(((long int )(s)*(x>>c) + tSampleMs));
};
    fb98:	0f 4e       	mov	r14,	r15	
    fb9a:	0e 4d       	mov	r13,	r14	
    fb9c:	0e 5a       	add	r10,	r14	
    fb9e:	0f 6b       	addc	r11,	r15	
    fba0:	39 41       	pop	r9		
    fba2:	3a 41       	pop	r10		
    fba4:	3b 41       	pop	r11		
    fba6:	30 41       	ret			
#define genRand02()  (rand ()%tSampleMs + (tSampleMs));
//#define genRand03()  ((rand ()+INT_MAX)%tSampleMs) + tSampleMs/2;
long int  genRand03(long int tSampleMs)  {
  //return(  (rand ()+INT_MAX)%tSampleMs + tSampleMs/2);
  int c;
  switch (sampleTimeSec){
    fba8:	0e 93       	tst	r14		
    fbaa:	c2 23       	jnz	$-122    	;abs 0xfb30
    break; 
    case 10:
     c = 3;
    break; 
    case 20:
     c = 2;
    fbac:	29 43       	mov	#2,	r9	;r3 As==10
    fbae:	cc 3f       	jmp	$-102    	;abs 0xfb48
#define genRand02()  (rand ()%tSampleMs + (tSampleMs));
//#define genRand03()  ((rand ()+INT_MAX)%tSampleMs) + tSampleMs/2;
long int  genRand03(long int tSampleMs)  {
  //return(  (rand ()+INT_MAX)%tSampleMs + tSampleMs/2);
  int c;
  switch (sampleTimeSec){
    fbb0:	0e 93       	tst	r14		
    fbb2:	c9 23       	jnz	$-108    	;abs 0xfb46
    break; 
    case 20:
     c = 2;
    break; 
    case 30:
     c = 1;
    fbb4:	19 43       	mov	#1,	r9	;r3 As==01
    fbb6:	c8 3f       	jmp	$-110    	;abs 0xfb48
  switch (sampleTimeSec){
    case 5:
     c = 4;
    break; 
    case 10:
     c = 3;
    fbb8:	39 40 03 00 	mov	#3,	r9	;#0x0003
    fbbc:	c5 3f       	jmp	$-116    	;abs 0xfb48
long int  genRand03(long int tSampleMs)  {
  //return(  (rand ()+INT_MAX)%tSampleMs + tSampleMs/2);
  int c;
  switch (sampleTimeSec){
    case 5:
     c = 4;
    fbbe:	29 42       	mov	#4,	r9	;r2 As==10
    fbc0:	c3 3f       	jmp	$-120    	;abs 0xfb48
     c = 0;
    break; 
  };

  int x = rand ();
  int s = (x > 0) ? 1 : ((x < 0) ? -1 : 0);
    fbc2:	09 93       	tst	r9		
    fbc4:	03 24       	jz	$+8      	;abs 0xfbcc
    fbc6:	0f 11       	rra	r15		
    fbc8:	19 83       	dec	r9		
    fbca:	fd 23       	jnz	$-4      	;abs 0xfbc6
    fbcc:	0d 4f       	mov	r15,	r13	
    fbce:	0e 4f       	mov	r15,	r14	
    fbd0:	8e 10       	swpb	r14		
    fbd2:	8e 11       	sxt	r14		
    fbd4:	8e 10       	swpb	r14		
    fbd6:	8e 11       	sxt	r14		
    fbd8:	3d e3       	inv	r13		
    fbda:	3e e3       	inv	r14		
    fbdc:	1d 53       	inc	r13		
    fbde:	0e 63       	adc	r14		
    fbe0:	c2 3f       	jmp	$-122    	;abs 0xfb66

0000fbe2 <Timer_A1>:

// Timer A1 interrupt service routine
interrupt (TIMERA1_VECTOR) Timer_A1 (void)
{
//   TACCTL1 &= ~CCIFG;                         /* Capture/compare interrupt flag */
   switch( TAIV )
    fbe2:	a2 93 2e 01 	cmp	#2,	&0x012e	;r3 As==10
    fbe6:	01 24       	jz	$+4      	;abs 0xfbea
       _BIC_SR_IRQ(LPM3_bits);                   // Clear LPM3 bits from 0(SR)
       break;
       case  4: 
       break;
   }
}
    fbe8:	00 13       	reti			
   switch( TAIV )
     {
       case 10: 
       break;
       case 2:
       CCR1 += dlyCC1;
    fbea:	92 52 04 02 	add	&0x0204,&0x0174	
    fbee:	74 01 
       // TAR = 0;
       _BIC_SR_IRQ(LPM3_bits);                   // Clear LPM3 bits from 0(SR)
    fbf0:	b1 c0 d0 00 	bic	#208,	0(r1)	;#0x00d0, 0x0000(r1)
    fbf4:	00 00 
       break;
       case  4: 
       break;
   }
}
    fbf6:	00 13       	reti			

0000fbf8 <setVloClk>:


void setVloClk (void){

    BCSCTL1 |= DIVA_0;                               // ACLK / 8
    BCSCTL2 |= SELM_3 + DIVM_3 + SELS + DIVS_3;               // MCLK = LFXT1/8
    fbf8:	f2 d0 fe ff 	bis.b	#-2,	&0x0058	;#0xfffe
    fbfc:	58 00 
    BCSCTL3 |= LFXT1S_2;                      // LFXT1 = VLO
    fbfe:	f2 d0 20 00 	bis.b	#32,	&0x0053	;#0x0020
    fc02:	53 00 
    IFG1 &= ~OFIFG;                           // Clear OSCFault flag
    fc04:	f2 f0 fd ff 	and.b	#-3,	&0x0002	;#0xfffd
    fc08:	02 00 
    __bis_SR_register(SCG1 + SCG0);           // Stop DCO
    fc0a:	32 d0 c0 00 	bis	#192,	r2	;#0x00c0


    CCTL1 = CCIE;                            // interrupt enabled CC1
    fc0e:	b2 40 10 00 	mov	#16,	&0x0164	;#0x0010
    fc12:	64 01 
    CCR1 = dlyCC1;
    fc14:	92 42 04 02 	mov	&0x0204,&0x0174	
    fc18:	74 01 
    TACTL = TASSEL_1 + MC_2;                 // ACLK, upmode
    fc1a:	b2 40 20 01 	mov	#288,	&0x0160	;#0x0120
    fc1e:	60 01 

}
    fc20:	30 41       	ret			

0000fc22 <setClockTrans>:

void setClockTrans(){

    BCSCTL1 = CALBC1_1MHZ;           // Set range
    fc22:	d2 42 ff 10 	mov.b	&0x10ff,&0x0057	
    fc26:	57 00 
    DCOCTL = CALDCO_1MHZ;            // SMCLK = DCO = 1MHz
    fc28:	d2 42 fe 10 	mov.b	&0x10fe,&0x0056	
    fc2c:	56 00 
    //BCSCTL2 |= SELM_1 + DIVM_0;               // MCLK = LFXT1/8
    BCSCTL2 = 0x00;               // MCLK = LFXT1/8
    fc2e:	c2 43 58 00 	mov.b	#0,	&0x0058	;r3 As==00

    //CCTL0 = CCIE;                            // interrupt enabled CC1
    //CCR0 = dlyCC0;
    //TACTL = TASSEL_2 + MC_2;                 // SMCLK, upmode

}
    fc32:	30 41       	ret			

0000fc34 <deviceID>:
    fc34:	23 00                                               #.

0000fc36 <minTime>:
    fc36:	88 13 00 00                                         ....

0000fc3a <Bitime>:
    fc3a:	68 00                                               h.

0000fc3c <asciiCode>:
    fc3c:	30 31 32 33 34 35 36 37 38 39 41 42 43 44 45 46     0123456789ABCDEF

0000fc4c <rand_r>:
    fc4c:	0b 12       	push	r11		
    fc4e:	0a 12       	push	r10		
    fc50:	09 12       	push	r9		
    fc52:	09 4f       	mov	r15,	r9	
    fc54:	2a 4f       	mov	@r15,	r10	
    fc56:	0b 43       	clr	r11		
    fc58:	0e 4a       	mov	r10,	r14	
    fc5a:	0f 4b       	mov	r11,	r15	
    fc5c:	4f ee       	xor.b	r14,	r15	
    fc5e:	0f ee       	xor	r14,	r15	
    fc60:	8f 10       	swpb	r15		
    fc62:	7e f3       	and.b	#-1,	r14	;r3 As==11
    fc64:	8e 10       	swpb	r14		
    fc66:	0e 5e       	rla	r14		
    fc68:	0f 6f       	rlc	r15		
    fc6a:	0e 8a       	sub	r10,	r14	
    fc6c:	0f 7b       	subc	r11,	r15	
    fc6e:	0e 5e       	rla	r14		
    fc70:	0f 6f       	rlc	r15		
    fc72:	0e 5e       	rla	r14		
    fc74:	0f 6f       	rlc	r15		
    fc76:	0e 5a       	add	r10,	r14	
    fc78:	0f 6b       	addc	r11,	r15	
    fc7a:	0c 4e       	mov	r14,	r12	
    fc7c:	0d 4f       	mov	r15,	r13	
    fc7e:	4d ec       	xor.b	r12,	r13	
    fc80:	0d ec       	xor	r12,	r13	
    fc82:	8d 10       	swpb	r13		
    fc84:	7c f3       	and.b	#-1,	r12	;r3 As==11
    fc86:	8c 10       	swpb	r12		
    fc88:	0c 5c       	rla	r12		
    fc8a:	0d 6d       	rlc	r13		
    fc8c:	0c 8e       	sub	r14,	r12	
    fc8e:	0d 7f       	subc	r15,	r13	
    fc90:	0c 5c       	rla	r12		
    fc92:	0d 6d       	rlc	r13		
    fc94:	0c 5a       	add	r10,	r12	
    fc96:	0d 6b       	addc	r11,	r13	
    fc98:	0e 4c       	mov	r12,	r14	
    fc9a:	0f 4d       	mov	r13,	r15	
    fc9c:	0e 5e       	rla	r14		
    fc9e:	0f 6f       	rlc	r15		
    fca0:	0e 5e       	rla	r14		
    fca2:	0f 6f       	rlc	r15		
    fca4:	0e 5e       	rla	r14		
    fca6:	0f 6f       	rlc	r15		
    fca8:	0e 5e       	rla	r14		
    fcaa:	0f 6f       	rlc	r15		
    fcac:	0e 5e       	rla	r14		
    fcae:	0f 6f       	rlc	r15		
    fcb0:	0e 5c       	add	r12,	r14	
    fcb2:	0f 6d       	addc	r13,	r15	
    fcb4:	0e 5e       	rla	r14		
    fcb6:	0f 6f       	rlc	r15		
    fcb8:	0e 5e       	rla	r14		
    fcba:	0f 6f       	rlc	r15		
    fcbc:	0e 8a       	sub	r10,	r14	
    fcbe:	0f 7b       	subc	r11,	r15	
    fcc0:	0e 5e       	rla	r14		
    fcc2:	0f 6f       	rlc	r15		
    fcc4:	0e 5e       	rla	r14		
    fcc6:	0f 6f       	rlc	r15		
    fcc8:	0e 5a       	add	r10,	r14	
    fcca:	0f 6b       	addc	r11,	r15	
    fccc:	3e 50 39 30 	add	#12345,	r14	;#0x3039
    fcd0:	0f 63       	adc	r15		
    fcd2:	89 4e 00 00 	mov	r14,	0(r9)	;0x0000(r9)
    fcd6:	0f 4e       	mov	r14,	r15	
    fcd8:	39 41       	pop	r9		
    fcda:	3a 41       	pop	r10		
    fcdc:	3b 41       	pop	r11		
    fcde:	30 41       	ret			

0000fce0 <rand>:
    fce0:	0b 12       	push	r11		
    fce2:	0a 12       	push	r10		
    fce4:	1a 42 08 02 	mov	&0x0208,r10	
    fce8:	1b 42 0a 02 	mov	&0x020a,r11	
    fcec:	0e 4a       	mov	r10,	r14	
    fcee:	0f 4b       	mov	r11,	r15	
    fcf0:	4f ee       	xor.b	r14,	r15	
    fcf2:	0f ee       	xor	r14,	r15	
    fcf4:	8f 10       	swpb	r15		
    fcf6:	7e f3       	and.b	#-1,	r14	;r3 As==11
    fcf8:	8e 10       	swpb	r14		
    fcfa:	0e 5e       	rla	r14		
    fcfc:	0f 6f       	rlc	r15		
    fcfe:	0e 8a       	sub	r10,	r14	
    fd00:	0f 7b       	subc	r11,	r15	
    fd02:	0e 5e       	rla	r14		
    fd04:	0f 6f       	rlc	r15		
    fd06:	0e 5e       	rla	r14		
    fd08:	0f 6f       	rlc	r15		
    fd0a:	0e 5a       	add	r10,	r14	
    fd0c:	0f 6b       	addc	r11,	r15	
    fd0e:	0c 4e       	mov	r14,	r12	
    fd10:	0d 4f       	mov	r15,	r13	
    fd12:	4d ec       	xor.b	r12,	r13	
    fd14:	0d ec       	xor	r12,	r13	
    fd16:	8d 10       	swpb	r13		
    fd18:	7c f3       	and.b	#-1,	r12	;r3 As==11
    fd1a:	8c 10       	swpb	r12		
    fd1c:	0c 5c       	rla	r12		
    fd1e:	0d 6d       	rlc	r13		
    fd20:	0c 8e       	sub	r14,	r12	
    fd22:	0d 7f       	subc	r15,	r13	
    fd24:	0c 5c       	rla	r12		
    fd26:	0d 6d       	rlc	r13		
    fd28:	0c 5a       	add	r10,	r12	
    fd2a:	0d 6b       	addc	r11,	r13	
    fd2c:	0e 4c       	mov	r12,	r14	
    fd2e:	0f 4d       	mov	r13,	r15	
    fd30:	0e 5e       	rla	r14		
    fd32:	0f 6f       	rlc	r15		
    fd34:	0e 5e       	rla	r14		
    fd36:	0f 6f       	rlc	r15		
    fd38:	0e 5e       	rla	r14		
    fd3a:	0f 6f       	rlc	r15		
    fd3c:	0e 5e       	rla	r14		
    fd3e:	0f 6f       	rlc	r15		
    fd40:	0e 5e       	rla	r14		
    fd42:	0f 6f       	rlc	r15		
    fd44:	0e 5c       	add	r12,	r14	
    fd46:	0f 6d       	addc	r13,	r15	
    fd48:	0e 5e       	rla	r14		
    fd4a:	0f 6f       	rlc	r15		
    fd4c:	0e 5e       	rla	r14		
    fd4e:	0f 6f       	rlc	r15		
    fd50:	0e 8a       	sub	r10,	r14	
    fd52:	0f 7b       	subc	r11,	r15	
    fd54:	0e 5e       	rla	r14		
    fd56:	0f 6f       	rlc	r15		
    fd58:	0e 5e       	rla	r14		
    fd5a:	0f 6f       	rlc	r15		
    fd5c:	0e 5a       	add	r10,	r14	
    fd5e:	0f 6b       	addc	r11,	r15	
    fd60:	3e 50 39 30 	add	#12345,	r14	;#0x3039
    fd64:	0f 63       	adc	r15		
    fd66:	82 4e 08 02 	mov	r14,	&0x0208	
    fd6a:	82 4f 0a 02 	mov	r15,	&0x020a	
    fd6e:	0f 4e       	mov	r14,	r15	
    fd70:	3a 41       	pop	r10		
    fd72:	3b 41       	pop	r11		
    fd74:	30 41       	ret			

0000fd76 <srand>:
    fd76:	82 4f 08 02 	mov	r15,	&0x0208	
    fd7a:	82 43 0a 02 	mov	#0,	&0x020a	;r3 As==00
    fd7e:	30 41       	ret			

0000fd80 <_unexpected_>:
    fd80:	00 13       	reti			

Disassembly of section .vectors:

0000ffe0 <__ivtbl_16>:
    ffe0:	32 f9 32 f9 32 f9 32 f9 32 f9 60 f9 32 f9 32 f9     2.2.2.2.2.`.2.2.
    fff0:	e2 fb a8 f9 32 f9 32 f9 32 f9 32 f9 32 f9 00 f8     ....2.2.2.2.2...
